<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".tt.out" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="..\..\Sweetener.Reliability\TextTemplating\Include.t4" #><#@ include file="..\TextTemplating\Include.t4" #><#
    for (int parameterCount = 0; parameterCount <= MaxDelegateParameters; parameterCount++)
    {
        string arguments              = GetArguments (parameterCount);
        string parameters             = GetParameters(typeArgs, parameterCount);
        string typeArguments          = GetTypeArgs  (parameterCount);
        string typeArgumentsNoBracket = GetTypeArgs  (parameterCount, includeBrackets: false);
        string typeParameters         = parameterCount == 0 ? string.Empty : "<" + GetTypeParameters(parameterCount) + ">";
        string testArguments          = GetTestArguments(parameterCount);
        string optionalComma          = parameterCount > 0 ? ", " : string.Empty;
        string suffix                 = parameterCount == 0 ? string.Empty : "T" + parameterCount;
#>
// Generated from <#= GetTemplateFileName() #>
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Sweetener.Reliability.Test
{
<#
        if (parameterCount == 0)
        {
#>
    [TestClass]
    public partial class ActionExtensionsTest
<#
        }
        else
        {
#>
    partial class ActionExtensionsTest
<#
        }
#>
    {
        [TestMethod]
        public void WithRetry<#= suffix #>_DelayPolicy()
        {
            Func<Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, InterruptableAction<#= typeArguments #>> withRetry = (a, r, e, d) => a.WithRetry(r, e, d);

            WithRetry<#= suffix #>_DelayPolicy_Success         (withRetry);
            WithRetry<#= suffix #>_DelayPolicy_Failure         (withRetry);
            WithRetry<#= suffix #>_DelayPolicy_EventualSuccess (withRetry);
            WithRetry<#= suffix #>_DelayPolicy_EventualFailure (withRetry);
            WithRetry<#= suffix #>_DelayPolicy_RetriesExhausted(withRetry);
        }

        [TestMethod]
        public void WithRetry<#= suffix #>_DelayPolicy_CancellationToken()
        {
            using CancellationTokenSource tokenSource = new CancellationTokenSource();
            Func<Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, InterruptableAction<#= typeArguments #>> withRetry = (a, r, e, d) => a.WithRetry(r, e, d);

            WithRetry<#= suffix #>_DelayPolicy_Success         (withRetry, useToken: true);
            WithRetry<#= suffix #>_DelayPolicy_Failure         (withRetry, useToken: true);
            WithRetry<#= suffix #>_DelayPolicy_EventualSuccess (withRetry, useToken: true);
            WithRetry<#= suffix #>_DelayPolicy_EventualFailure (withRetry, useToken: true);
            WithRetry<#= suffix #>_DelayPolicy_RetriesExhausted(withRetry, useToken: true);
            WithRetry<#= suffix #>_DelayPolicy_Canceled        (withRetry);
        }

        [TestMethod]
        public void WithRetry<#= suffix #>_ComplexDelayPolicy()
        {
            Func<Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, InterruptableAction<#= typeArguments #>> withRetry = (a, r, e, d) => a.WithRetry(r, e, d);

            WithRetry<#= suffix #>_ComplexDelayPolicy_Success         (withRetry);
            WithRetry<#= suffix #>_ComplexDelayPolicy_Failure         (withRetry);
            WithRetry<#= suffix #>_ComplexDelayPolicy_EventualSuccess (withRetry);
            WithRetry<#= suffix #>_ComplexDelayPolicy_EventualFailure (withRetry);
            WithRetry<#= suffix #>_ComplexDelayPolicy_RetriesExhausted(withRetry);
        }

        [TestMethod]
        public void WithRetry<#= suffix #>_ComplexDelayPolicy_CancellationToken()
        {
            using CancellationTokenSource tokenSource = new CancellationTokenSource();
            Func<Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, InterruptableAction<#= typeArguments #>> withRetry = (a, r, e, d) => a.WithRetry(r, e, d);

            WithRetry<#= suffix #>_ComplexDelayPolicy_Success         (withRetry, useToken: true);
            WithRetry<#= suffix #>_ComplexDelayPolicy_Failure         (withRetry, useToken: true);
            WithRetry<#= suffix #>_ComplexDelayPolicy_EventualSuccess (withRetry, useToken: true);
            WithRetry<#= suffix #>_ComplexDelayPolicy_EventualFailure (withRetry, useToken: true);
            WithRetry<#= suffix #>_ComplexDelayPolicy_RetriesExhausted(withRetry, useToken: true);
            WithRetry<#= suffix #>_ComplexDelayPolicy_Canceled        (withRetry);
        }

        private void WithRetry<#= suffix #>_DelayPolicy_Success(Func<Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, InterruptableAction<#= typeArguments #>> withRetry, bool useToken = false)
            => WithRetry<#= suffix #>_Success((a, r, e, d) => withRetry(a, r, e, d.Invoke), () => PolicyValidator.IgnoreDelayPolicy(), useToken);

        private void WithRetry<#= suffix #>_ComplexDelayPolicy_Success(Func<Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, InterruptableAction<#= typeArguments #>> withRetry, bool useToken = false)
            => WithRetry<#= suffix #>_Success((a, r, e, d) => withRetry(a, r, e, d.Invoke), () => PolicyValidator.IgnoreComplexDelayPolicy(), useToken);

        private void WithRetry<#= suffix #>_Success<T>(Func<Action<#= typeArguments #>, int, ExceptionPolicy, T, InterruptableAction<#= typeArguments #>> withRetry, Func<T> delayPolicyFactory, bool useToken = false)
            where T : ObservableFunc
        {
            ObservableFunc<Exception, bool> exceptionPolicy = PolicyValidator.IgnoreExceptionPolicy();
            T delayPolicy = delayPolicyFactory();

            InterruptableAction<#= typeArguments #> reliableAction = withRetry(
                (<#= arguments #>) => <#= parameterCount > 0 ? "Arguments.Validate(" + arguments + ")" : "Operation.Null()" #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy);

            if (useToken)
            {
                using CancellationTokenSource tokenSource = new CancellationTokenSource();
                reliableAction(<#= testArguments #><#= optionalComma #>tokenSource.Token);
            }
            else
            {
                reliableAction(<#= testArguments #>);
            }

            Assert.AreEqual(0, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        private void WithRetry<#= suffix #>_DelayPolicy_Failure(Func<Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, InterruptableAction<#= typeArguments #>> withRetry, bool useToken = false)
            => WithRetry<#= suffix #>_Failure((a, r, e, d) => withRetry(a, r, e, d.Invoke), () => PolicyValidator.IgnoreDelayPolicy(), useToken);

        private void WithRetry<#= suffix #>_ComplexDelayPolicy_Failure(Func<Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, InterruptableAction<#= typeArguments #>> withRetry, bool useToken = false)
            => WithRetry<#= suffix #>_Failure((a, r, e, d) => withRetry(a, r, e, d.Invoke), () => PolicyValidator.IgnoreComplexDelayPolicy(), useToken);

        private void WithRetry<#= suffix #>_Failure<T>(Func<Action<#= typeArguments #>, int, ExceptionPolicy, T, InterruptableAction<#= typeArguments #>> withRetry, Func<T> delayPolicyFactory, bool useToken = false)
            where T : ObservableFunc
        {
            ObservableFunc<Exception, bool> exceptionPolicy = PolicyValidator.Create<FormatException>(ExceptionPolicies.Fail<FormatException>());
            T delayPolicy = delayPolicyFactory();

            InterruptableAction<#= typeArguments #> reliableAction = withRetry(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    Arguments.Validate(<#= arguments #>);
<#
        }
#>
                    throw new FormatException();
                },
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy);

            try
            {
                if (useToken)
                {
                    using CancellationTokenSource tokenSource = new CancellationTokenSource();
                    reliableAction(<#= testArguments #><#= optionalComma #>tokenSource.Token);
                }
                else
                {
                    reliableAction(<#= testArguments #>);
                }

                Assert.Fail();
            }
            catch (FormatException)
            { }
            catch (AssertFailedException)
            {
                throw;
            }
            catch (Exception)
            {
                Assert.Fail();
            }

            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        private void WithRetry<#= suffix #>_DelayPolicy_EventualSuccess(Func<Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, InterruptableAction<#= typeArguments #>> withRetry, bool useToken = false)
            => WithRetry<#= suffix #>_EventualSuccess<IOException, ObservableFunc<int, TimeSpan>>((a, r, e, d) => withRetry(a, r, e, d.Invoke), t => PolicyValidator.Create(DelayPolicies.Constant(t)), useToken);

        private void WithRetry<#= suffix #>_ComplexDelayPolicy_EventualSuccess(Func<Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, InterruptableAction<#= typeArguments #>> withRetry, bool useToken = false)
            => WithRetry<#= suffix #>_EventualSuccess<IOException, ObservableFunc<int, Exception, TimeSpan>>((a, r, e, d) => withRetry(a, r, e, d.Invoke), t => PolicyValidator.Create<IOException>((i, e) => t), useToken);

        private void WithRetry<#= suffix #>_EventualSuccess<TException, TFunc>(Func<Action<#= typeArguments #>, int, ExceptionPolicy, TFunc, InterruptableAction<#= typeArguments #>> withRetry, Func<TimeSpan, TFunc> delayPolicyFactory, bool useToken = false)
            where TException : Exception, new()
            where TFunc      : ObservableFunc
        {
            ObservableFunc<Exception, bool> exceptionPolicy = PolicyValidator.Create<TException>(ExceptionPolicies.Retry<TException>());
            TFunc delayPolicy = delayPolicyFactory(Constants.Delay);

            Action eventualSuccess = FlakyAction.Create<TException>(1);
            InterruptableAction<#= typeArguments #> reliableAction = withRetry(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    Arguments.Validate(<#= arguments #>);
<#
        }
#>
                    eventualSuccess();
                },
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy);

            DateTime delayStartUtc = DateTime.UtcNow;
            if (useToken)
            {
                using CancellationTokenSource tokenSource = new CancellationTokenSource();
                reliableAction(<#= testArguments #><#= optionalComma #>tokenSource.Token);
            }
            else
            {
                reliableAction(<#= testArguments #>);
            }
            TimeSpan delay = DateTime.UtcNow - delayStartUtc;

            Assert.IsTrue(delay > Constants.MinDelay);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(1, delayPolicy    .Calls);
        }

        private void WithRetry<#= suffix #>_DelayPolicy_EventualFailure(Func<Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, InterruptableAction<#= typeArguments #>> withRetry, bool useToken = false)
            => WithRetry<#= suffix #>_EventualFailure<IOException, ObservableFunc<int, TimeSpan>>((a, r, e, d) => withRetry(a, r, e, d.Invoke), t => PolicyValidator.Create(DelayPolicies.Constant(t)), useToken);

        private void WithRetry<#= suffix #>_ComplexDelayPolicy_EventualFailure(Func<Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, InterruptableAction<#= typeArguments #>> withRetry, bool useToken = false)
            => WithRetry<#= suffix #>_EventualFailure<IOException, ObservableFunc<int, Exception, TimeSpan>>((a, r, e, d) => withRetry(a, r, e, d.Invoke), t => PolicyValidator.Create<IOException>((i, e) => t), useToken);

        private void WithRetry<#= suffix #>_EventualFailure<TTransient, TFunc>(Func<Action<#= typeArguments #>, int, ExceptionPolicy, TFunc, InterruptableAction<#= typeArguments #>> withRetry, Func<TimeSpan, TFunc> delayPolicyFactory, bool useToken = false)
            where TTransient : Exception, new()
            where TFunc      : ObservableFunc
        {
            Assert.AreNotEqual(typeof(TTransient), typeof(InvalidOperationException));

            ObservableFunc<Exception, bool> exceptionPolicy = PolicyValidator.Create<TTransient, InvalidOperationException>(ExceptionPolicies.Retry<TTransient>());
            TFunc delayPolicy = delayPolicyFactory(Constants.Delay);

            Action eventualFailure = FlakyAction.Create<TTransient, InvalidOperationException>(2);
            InterruptableAction<#= typeArguments #> reliableAction = withRetry(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    Arguments.Validate(<#= arguments #>);
<#
        }
#>
                    eventualFailure();
                },
                4,
                exceptionPolicy.Invoke,
                delayPolicy);

            DateTime delayStartUtc = DateTime.UtcNow;

            try
            {
                if (useToken)
                {
                    using CancellationTokenSource tokenSource = new CancellationTokenSource();
                    reliableAction(<#= testArguments #><#= optionalComma #>tokenSource.Token);
                }
                else
                {
                    reliableAction(<#= testArguments #>);
                }

                Assert.Fail();
            }
            catch (InvalidOperationException)
            { }
            catch (AssertFailedException)
            {
                throw;
            }
            catch (Exception)
            {
                Assert.Fail();
            }

            TimeSpan delay = DateTime.UtcNow - delayStartUtc;
            Assert.IsTrue(delay > TimeSpan.FromMilliseconds(Constants.Delay.TotalMilliseconds * 2 * Constants.MinFactor));

            Assert.AreEqual(3, exceptionPolicy.Calls);
            Assert.AreEqual(2, delayPolicy    .Calls);
        }

        private void WithRetry<#= suffix #>_DelayPolicy_RetriesExhausted(Func<Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, InterruptableAction<#= typeArguments #>> withRetry, bool useToken = false)
            => WithRetry<#= suffix #>_RetriesExhausted<IOException, ObservableFunc<int, TimeSpan>>((a, r, e, d) => withRetry(a, r, e, d.Invoke), t => PolicyValidator.Create(DelayPolicies.Constant(t)), useToken);

        private void WithRetry<#= suffix #>_ComplexDelayPolicy_RetriesExhausted(Func<Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, InterruptableAction<#= typeArguments #>> withRetry, bool useToken = false)
            => WithRetry<#= suffix #>_RetriesExhausted<IOException, ObservableFunc<int, Exception, TimeSpan>>((a, r, e, d) => withRetry(a, r, e, d.Invoke), t => PolicyValidator.Create<IOException>((i, e) => t), useToken);

        private void WithRetry<#= suffix #>_RetriesExhausted<TException, TFunc>(Func<Action<#= typeArguments #>, int, ExceptionPolicy, TFunc, InterruptableAction<#= typeArguments #>> withRetry, Func<TimeSpan, TFunc> delayPolicyFactory, bool useToken = false)
            where TException : Exception, new()
            where TFunc      : ObservableFunc
        {
            DateTime delayStartUtc = DateTime.MinValue;
            ObservableFunc<Exception, bool> exceptionPolicy = PolicyValidator.Create<TException>(ExceptionPolicies.Retry<TException>());
            TFunc delayPolicy = delayPolicyFactory(Constants.Delay);

            InterruptableAction<#= typeArguments #> reliableAction = withRetry(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    Arguments.Validate(<#= arguments #>);
<#
        }
#>
                    throw new TException();
                },
                2,
                exceptionPolicy.Invoke,
                delayPolicy);

            try
            {
                if (useToken)
                {
                    using CancellationTokenSource tokenSource = new CancellationTokenSource();
                    reliableAction(<#= testArguments #><#= optionalComma #>tokenSource.Token);
                }
                else
                {
                    reliableAction(<#= testArguments #>);
                }

                Assert.Fail();
            }
            catch (TException)
            { }
            catch (AssertFailedException)
            {
                throw;
            }
            catch (Exception)
            {
                Assert.Fail();
            }

            TimeSpan delay = DateTime.UtcNow - delayStartUtc;
            Assert.IsTrue(delay > TimeSpan.FromMilliseconds(Constants.Delay.TotalMilliseconds * 2 * Constants.MinFactor));

            Assert.AreEqual(3, exceptionPolicy.Calls);
            Assert.AreEqual(2, delayPolicy    .Calls);
        }

        private void WithRetry<#= suffix #>_DelayPolicy_Canceled(Func<Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, InterruptableAction<#= typeArguments #>> withRetry)
            => WithRetry<#= suffix #>_Canceled<IOException, ObservableFunc<int, TimeSpan>>((a, r, e, d) => withRetry(a, r, e, d.Invoke), t => PolicyValidator.Create(DelayPolicies.Constant(t)));

        private void WithRetry<#= suffix #>_ComplexDelayPolicy_Canceled(Func<Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, InterruptableAction<#= typeArguments #>> withRetry)
            => WithRetry<#= suffix #>_Canceled<IOException, ObservableFunc<int, Exception, TimeSpan>>((a, r, e, d) => withRetry(a, r, e, d.Invoke), t => PolicyValidator.Create<IOException>((i, e) => t));

        private void WithRetry<#= suffix #>_Canceled<TException, TFunc>(Func<Action<#= typeArguments #>, int, ExceptionPolicy, TFunc, InterruptableAction<#= typeArguments #>> withRetry, Func<TimeSpan, TFunc> delayPolicyFactory)
            where TException : Exception, new()
            where TFunc      : ObservableFunc
        {
            using ManualResetEvent        retryEvent  = new ManualResetEvent(false);
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            ObservableFunc<Exception, bool> exceptionPolicy = PolicyValidator.Create<TException>(ExceptionPolicies.Retry<TException>());
            TFunc delayPolicy = delayPolicyFactory(Constants.Delay);

            exceptionPolicy.Invoking += e =>
            {
                if (exceptionPolicy.Calls > 1)
                    retryEvent.Set();
            };

            InterruptableAction<#= typeArguments #> reliableAction = withRetry(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    Arguments.Validate(<#= arguments #>);
<#
        }
#>
                    throw new TException();
                },
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy);

            // While waiting for the reliable action to complete, we'll cancel it
            Task invocation = Task.Run(() => reliableAction(<#= testArguments #><#= optionalComma #>tokenSource.Token), tokenSource.Token);

            // Cancel after at least 1 retry has occurred
            retryEvent.WaitOne();
            tokenSource.Cancel();

            // Try to get the result
            try
            {
                invocation.Wait();
                Assert.Fail();
            }
            catch (AggregateException agg)
            {
                Assert.AreEqual(1, agg.InnerExceptions.Count);
                switch (agg.InnerException)
                {
                    case AssertFailedException afe:
                        throw afe;
                    case TaskCanceledException _:
                        Assert.IsTrue(exceptionPolicy.Calls > 0);
                        Assert.IsTrue(delayPolicy    .Calls > 0);
                        Assert.AreEqual(exceptionPolicy.Calls, delayPolicy.Calls);
                        return; // Successfully cancelled
                    default:
                        Assert.Fail();
                        break;
                }
            }
            catch (Exception)
            {
                Assert.Fail();
            }
        }
    }
}
<#
        string fileName = parameterCount == 0 ? "Action.Extensions.Test.cs" : $"Action.Extensions.T{parameterCount}.Test.cs";
        SaveOutput(fileName);
    }
#>
<#= GetTemplateFileName() #> ran successfully
