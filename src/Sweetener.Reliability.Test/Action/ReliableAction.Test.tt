<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".tt.out" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="..\..\Sweetener.Reliability\TextTemplating\Include.t4" #><#@ include file="..\TextTemplating\Include.t4" #><#
    for (int parameterCount = 0; parameterCount <= MaxDelegateParameters; parameterCount++)
    {
        string arguments              = GetArguments (parameterCount);
        string parameters             = GetParameters(typeArgs, parameterCount);
        string typeArguments          = GetTypeArgs  (parameterCount);
        string typeArgumentsNoBracket = GetTypeArgs  (parameterCount, includeBrackets: false);
        string typeParameters         = parameterCount == 0 ? string.Empty : "<" + GetTypeParameters(parameterCount) + ">";
        string testArguments          = GetTestArguments(parameterCount);
        string optionalComma          = parameterCount > 0 ? ", " : string.Empty;
#>
// Generated from <#= GetTemplateFileName() #>
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Sweetener.Reliability.Test
{
    [TestClass]
    public sealed class ReliableAction<#= parameterCount > 0 ? parameterCount.ToString() : string.Empty #>Test : ReliableDelegateTest
    {
        private static readonly Func<ReliableAction<#= typeArguments #>, Action<#= typeArguments #>> s_getAction = DynamicGetter.ForField<ReliableAction<#= typeArguments #>, Action<#= typeArguments #>>("_action");

        [TestMethod]
        public void Ctor_DelayPolicy()
        {
            Assert.ThrowsException<ArgumentNullException      >(() => new ReliableAction<#= typeArguments #>(null, Retries.Infinite, ExceptionPolicies.Fatal, DelayPolicies.None));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => new ReliableAction<#= typeArguments #>((<#= arguments #>) => Console.WriteLine("Hello World"), -2              , ExceptionPolicies.Fatal, DelayPolicies.None));
            Assert.ThrowsException<ArgumentNullException      >(() => new ReliableAction<#= typeArguments #>((<#= arguments #>) => Console.WriteLine("Hello World"), Retries.Infinite, null                   , DelayPolicies.None));
            Assert.ThrowsException<ArgumentNullException      >(() => new ReliableAction<#= typeArguments #>((<#= arguments #>) => Console.WriteLine("Hello World"), Retries.Infinite, ExceptionPolicies.Fatal, (DelayPolicy)null ));

            Action<#= typeArguments #> action = (<#= arguments #>) => Console.WriteLine("Hello World");
            ReliableAction<#= typeArguments #> actual = new ReliableAction<#= typeArguments #>(action, 37, ExceptionPolicies.Transient, DelayPolicies.Constant(115));

            // DelayPolicies are wrapped in ComplexDelayPolicies, so we can only validate the correct assignment by invoking the policy
            Ctor(actual, action, 37, ExceptionPolicies.Transient, actualPolicy =>
            {
                Assert.AreEqual(TimeSpan.FromMilliseconds(115), actualPolicy( 1, new Exception()));
                Assert.AreEqual(TimeSpan.FromMilliseconds(115), actualPolicy( 2, new Exception()));
                Assert.AreEqual(TimeSpan.FromMilliseconds(115), actualPolicy(10, new Exception()));
            });
        }

        [TestMethod]
        public void Ctor_ComplexDelayPolicy()
        {
            Assert.ThrowsException<ArgumentNullException      >(() => new ReliableAction<#= typeArguments #>(null, Retries.Infinite, ExceptionPolicies.Fatal, (i, e) => TimeSpan.Zero));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => new ReliableAction<#= typeArguments #>((<#= arguments #>) => Console.WriteLine("Hello World"), -2              , ExceptionPolicies.Fatal, (i, e) => TimeSpan.Zero ));
            Assert.ThrowsException<ArgumentNullException      >(() => new ReliableAction<#= typeArguments #>((<#= arguments #>) => Console.WriteLine("Hello World"), Retries.Infinite, null                   , (i, e) => TimeSpan.Zero ));
            Assert.ThrowsException<ArgumentNullException      >(() => new ReliableAction<#= typeArguments #>((<#= arguments #>) => Console.WriteLine("Hello World"), Retries.Infinite, ExceptionPolicies.Fatal, (ComplexDelayPolicy)null));

            ComplexDelayPolicy delayPolicy = (i, e) => TimeSpan.Zero;
            Action<#= typeArguments #> action = (<#= arguments #>) => Console.WriteLine("Hello World");
            ReliableAction<#= typeArguments #> actual = new ReliableAction<#= typeArguments #>(action, 37, ExceptionPolicies.Transient, delayPolicy);

            Ctor(actual, action, 37, ExceptionPolicies.Transient, delayPolicy);
        }

        private void Ctor(ReliableAction<#= typeArguments #> reliableAction, Action<#= typeArguments #> expectedAction, int expectedMaxRetries, ExceptionPolicy expectedExceptionPolicy, ComplexDelayPolicy expectedDelayPolicy)
            => Ctor(reliableAction, expectedAction, expectedMaxRetries, expectedExceptionPolicy, actual => Assert.AreSame(expectedDelayPolicy, actual));

        private void Ctor(ReliableAction<#= typeArguments #> reliableAction, Action<#= typeArguments #> expectedAction, int expectedMaxRetries, ExceptionPolicy expectedExceptionPolicy, Action<ComplexDelayPolicy> validateDelayPolicy)
        {
            Assert.AreSame (expectedAction, s_getAction(reliableAction));
            Assert.AreEqual(expectedMaxRetries, reliableAction.MaxRetries);
            Assert.AreSame (expectedExceptionPolicy, s_getExceptionPolicy(reliableAction));

            validateDelayPolicy(s_getDelayPolicy(reliableAction));
        }

        [TestMethod]
        public void Invoke_NoCancellationToken()
            => Invoke((reliableAction<#= optionalComma #><#= arguments #>) => reliableAction.Invoke(<#= arguments #>));

        [TestMethod]
        public void Invoke_CancellationToken()
        {
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Invoke((reliableAction<#= optionalComma #><#= arguments #>) => reliableAction.Invoke(<#= arguments #><#= optionalComma #>tokenSource.Token));

            // Ensure CancellationToken prevents additional retry
            Invoke_Canceled((reliableAction<#= optionalComma #><#= arguments #>, token) => reliableAction.Invoke(<#= arguments #><#= optionalComma #>token));
        }

        [TestMethod]
        public void TryInvoke_NoCancellationToken()
            => TryInvoke((reliableAction<#= optionalComma #><#= arguments #>) => reliableAction.TryInvoke(<#= arguments #>));

        [TestMethod]
        public void TryInvoke_CancellationToken()
        {
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                TryInvoke((reliableAction<#= optionalComma #><#= arguments #>) => reliableAction.TryInvoke(<#= arguments #><#= optionalComma #>tokenSource.Token));
        
            // Ensure CancellationToken prevents additional retry
            Invoke_Canceled((reliableAction<#= optionalComma #><#= arguments #>, token) => reliableAction.TryInvoke(<#= arguments #><#= optionalComma #>token));
        }

        private void Invoke(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> invoke)
        {
            Invoke_Success        (invoke);
            Invoke_EventualSuccess(invoke);

            Invoke_Failure         <             InvalidOperationException>(GetFailureAssertion<InvalidOperationException>());
            Invoke_EventualFailure <IOException, InvalidOperationException>(GetFailureAssertion<InvalidOperationException>());
            Invoke_RetriesExhausted<IOException                           >(GetFailureAssertion<IOException              >());

            Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> GetFailureAssertion<T>()
                where T : Exception
            {
                return (r<#= optionalComma #><#= arguments #>) =>
                {
                    try
                    {
                        invoke(r<#= optionalComma #><#= arguments #>);
                        Assert.Fail();
                    }
                    catch (T)
                    { }
                    catch (Exception)
                    {
                        Assert.Fail();
                    }
                };
            }
        }

        private void TryInvoke(Func<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, bool> tryInvoke)
        {
            Invoke_Success                                                 ((r<#= optionalComma #><#= arguments #>) => Assert.IsTrue (tryInvoke(r<#= optionalComma #><#= arguments #>)));
            Invoke_EventualSuccess                                         ((r<#= optionalComma #><#= arguments #>) => Assert.IsTrue (tryInvoke(r<#= optionalComma #><#= arguments #>)));
            Invoke_Failure         <             InvalidOperationException>((r<#= optionalComma #><#= arguments #>) => Assert.IsFalse(tryInvoke(r<#= optionalComma #><#= arguments #>)));
            Invoke_EventualFailure <IOException, InvalidOperationException>((r<#= optionalComma #><#= arguments #>) => Assert.IsFalse(tryInvoke(r<#= optionalComma #><#= arguments #>)));
            Invoke_RetriesExhausted<IOException                           >((r<#= optionalComma #><#= arguments #>) => Assert.IsFalse(tryInvoke(r<#= optionalComma #><#= arguments #>)));
        }

        private void Invoke_Success(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> assertInvoke)
        {
            ObservableFunc<Exception, bool    > exceptionPolicy = PolicyValidator.Create(ExceptionPolicies.Fatal);
            ObservableFunc<int      , TimeSpan> delayPolicy     = PolicyValidator.Create(DelayPolicies.None);

            ReliableAction<#= typeArguments #> reliableAction = new ReliableAction<#= typeArguments #>(
                (<#= arguments #>) => <#= parameterCount > 0 ? "AssertDelegateParameters(" + arguments + ")" : "Console.WriteLine(\"Success\")" #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            reliableAction.Retrying         += (i, e) => Assert.Fail();
            reliableAction.Failed           +=     e  => Assert.Fail();
            reliableAction.RetriesExhausted +=     e  => Assert.Fail();

            assertInvoke(reliableAction<#= optionalComma #><#= testArguments #>);

            Assert.AreEqual(0, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        private void Invoke_Failure<T>(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> assertInvoke)
            where T : Exception, new()
        {
            ObservableFunc<Exception     , bool    > exceptionPolicy = PolicyValidator.Create<T>(ExceptionPolicies.Fail<T>());
            ObservableFunc<int, Exception, TimeSpan> delayPolicy     = PolicyValidator.Create<T>((i, e) => TimeSpan.Zero);

            ReliableAction<#= typeArguments #> reliableAction = new ReliableAction<#= typeArguments #>(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    AssertDelegateParameters(<#= arguments #>);
<#
        }
#>
                    throw new T();
                },
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            int failures = 0;
            reliableAction.Retrying         += (i, e) => Assert.Fail();
            reliableAction.RetriesExhausted +=     e  => Assert.Fail();
            reliableAction.Failed           +=     e  => { failures++; Assert.AreEqual(typeof(T), e.GetType()); };

            assertInvoke(reliableAction<#= optionalComma #><#= testArguments #>);

            Assert.AreEqual(1, failures);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        private void Invoke_EventualSuccess(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> assertInvoke)
        {
            DateTime delayStartUtc = DateTime.MinValue;
            ObservableFunc<Exception, bool    > exceptionPolicy = PolicyValidator.Create<IOException>(ExceptionPolicies.Retry<IOException>());
            ObservableFunc<int      , TimeSpan> delayPolicy     = PolicyValidator.Create(DelayPolicies.Constant(ConstantDelay));

            delayPolicy.Invoked += (i, d) => delayStartUtc = DateTime.UtcNow;

            Action eventualSuccess = FlakyAction.Create<IOException>(1);
            ReliableAction<#= typeArguments #> reliableAction = new ReliableAction<#= typeArguments #>(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    AssertDelegateParameters(<#= arguments #>);
<#
        }
#>
                    eventualSuccess();
                },
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            int retries = 0;
            reliableAction.Retrying += (i, e) =>
            {
                Assert.AreEqual(++retries, i);
                Assert.AreEqual(typeof(IOException), e.GetType());

                TimeSpan actual = DateTime.UtcNow - delayStartUtc;
                Assert.IsTrue(actual > MinDelay, $"Actual delay {actual} less than allowed minimum delay {MinDelay}");
            };
            reliableAction.Failed           += e => Assert.Fail();
            reliableAction.RetriesExhausted += e => Assert.Fail();

            assertInvoke(reliableAction<#= optionalComma #><#= testArguments #>);

            Assert.AreEqual(1, retries);
            Assert.AreEqual(retries, exceptionPolicy.Calls);
            Assert.AreEqual(retries, delayPolicy    .Calls);
        }

        private void Invoke_EventualFailure<TTransient, TFatal>(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> assertInvoke)
            where TTransient : Exception, new()
            where TFatal     : Exception, new()
        {
            DateTime delayStartUtc = DateTime.MinValue;
            ObservableFunc<Exception, bool    > exceptionPolicy = PolicyValidator.Create<TTransient, TFatal>(ExceptionPolicies.Retry<TTransient>());
            ObservableFunc<int      , TimeSpan> delayPolicy     = PolicyValidator.Create(DelayPolicies.Constant(ConstantDelay));

            delayPolicy.Invoked += (i, d) => delayStartUtc = DateTime.UtcNow;

            Action eventualFailure = FlakyAction.Create<TTransient, TFatal>(2);
            ReliableAction<#= typeArguments #> reliableAction = new ReliableAction<#= typeArguments #>(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    AssertDelegateParameters(<#= arguments #>);
<#
        }
#>
                    eventualFailure();
                },
                4,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            int retries = 0, failures = 0;
            reliableAction.Retrying += (i, e) =>
            {
                Assert.AreEqual(++retries, i);
                Assert.AreEqual(typeof(TTransient), e.GetType());

                TimeSpan actual = DateTime.UtcNow - delayStartUtc;
                Assert.IsTrue(actual > MinDelay, $"Actual delay {actual} less than allowed minimum delay {MinDelay}");
            };
            reliableAction.Failed           += e => { failures++; Assert.AreEqual(typeof(TFatal), e.GetType()); };
            reliableAction.RetriesExhausted += e => Assert.Fail();

            assertInvoke(reliableAction<#= optionalComma #><#= testArguments #>);

            Assert.AreEqual(2, retries );
            Assert.AreEqual(1, failures);
            Assert.AreEqual(retries + 1, exceptionPolicy.Calls);
            Assert.AreEqual(retries    , delayPolicy    .Calls);
        }

        private void Invoke_RetriesExhausted<T>(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> assertInvoke)
            where T : Exception, new()
        {
            DateTime delayStartUtc = DateTime.MinValue;
            ObservableFunc<Exception     , bool    > exceptionPolicy = PolicyValidator.Create<T>(ExceptionPolicies.Retry<T>());
            ObservableFunc<int, Exception, TimeSpan> delayPolicy     = PolicyValidator.Create<T>((i, e) => ConstantDelay); // A "complex" delay policy

            delayPolicy.Invoked += (i, e, d) => delayStartUtc = DateTime.UtcNow;

            ReliableAction<#= typeArguments #> reliableAction = new ReliableAction<#= typeArguments #>(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    AssertDelegateParameters(<#= arguments #>);
<#
        }
#>
                    throw new T();
                },
                2,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            int retries = 0, exhausted = 0;
            reliableAction.Retrying += (i, e) =>
            {
                Assert.AreEqual(++retries, i);
                Assert.AreEqual(typeof(T), e.GetType());

                TimeSpan actual = DateTime.UtcNow - delayStartUtc;
                Assert.IsTrue(actual > MinDelay, $"Actual delay {actual} less than allowed minimum delay {MinDelay}");
            };
            reliableAction.Failed           += e => Assert.Fail();
            reliableAction.RetriesExhausted += e => { exhausted++; Assert.AreEqual(typeof(T), e.GetType()); };

            assertInvoke(reliableAction<#= optionalComma #><#= testArguments #>);

            Assert.AreEqual(2, retries  );
            Assert.AreEqual(1, exhausted);
            Assert.AreEqual(retries + 1, exceptionPolicy.Calls);
            Assert.AreEqual(retries    , delayPolicy    .Calls);
        }

        private void Invoke_Canceled(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> assertInvoke)
        {
            using ManualResetEvent        retryEvent  = new ManualResetEvent(false);
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            ObservableFunc<Exception, bool    > exceptionPolicy = PolicyValidator.Create<IOException>(ExceptionPolicies.Retry<IOException>());
            ObservableFunc<int      , TimeSpan> delayPolicy     = PolicyValidator.Create(DelayPolicies.None);

            ReliableAction<#= typeArguments #> reliableAction = new ReliableAction<#= typeArguments #>(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    AssertDelegateParameters(<#= arguments #>);
<#
        }
#>
                    throw new IOException();
                },
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            int retries = 0;
            reliableAction.Retrying += (i, e) =>
            {
                Assert.AreEqual(++retries, i);
                Assert.AreEqual(typeof(IOException), e.GetType());
                retryEvent.Set();
            };
            reliableAction.Failed           += e => Assert.Fail();
            reliableAction.RetriesExhausted += e => Assert.Fail();

            // While waiting for the reliable action to complete, we'll cancel it
            Task invocation = Task.Run(() => assertInvoke(reliableAction<#= optionalComma #><#= testArguments #>, tokenSource.Token), tokenSource.Token);

            // Cancel after at least 1 retry has occurred
            retryEvent.WaitOne();
            tokenSource.Cancel();

            // Try to get the result
            try
            {
                invocation.Wait();
                Assert.Fail();
            }
            catch (AggregateException agg)
            {
                Assert.AreEqual(1, agg.InnerExceptions.Count);
                switch (agg.InnerException)
                {
                    case AssertFailedException afe:
                        throw afe;
                    case TaskCanceledException _:
                        Assert.IsTrue(retries > 0);
                        Assert.AreEqual(retries + 1, exceptionPolicy.Calls);
                        Assert.AreEqual(retries + 1, delayPolicy    .Calls);
                        return; // Successfully cancelled
                    default:
                        Assert.Fail();
                        break;
                }
            }
            catch (Exception)
            {
                Assert.Fail();
            }
        }
<#
        if (parameterCount > 0)
        {
#>

        private static void AssertDelegateParameters(<#= parameters #>)
        {
<#
            int maxArgLength = args.Take(parameterCount).Select(x => x.Length).Max();
            for (int i = 0; i < parameterCount; i++)
            {
#>
            Assert.AreEqual(<#= args[i].PadRight(maxArgLength) #>, <#= parameterCount == 1 ? "arg" : "arg" + (i + 1) #>);
<#
            }
#>
        }
<#
        }
#>
    }
}
<#
        string fileName = parameterCount == 0 ? "ReliableAction.Test.cs" : $"ReliableAction.T{parameterCount}.Test.cs";
        SaveOutput(fileName);
    }
#>
<#= GetTemplateFileName() #> ran successfully
