<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="..\..\Sweetener.Reliability\TextTemplating\Include.t4" #>// Generated from ReliableAction.Test.tt
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Sweetener.Reliability.Test
{
<#
    for (int parameterCount = 0; parameterCount <= MaxDelegateParameters; parameterCount++)
    {
        string arguments              = GetArguments (parameterCount);
        string parameters             = GetParameters(typeArgs, parameterCount);
        string typeArguments          = GetTypeArgs  (parameterCount);
        string typeArgumentsNoBracket = GetTypeArgs(parameterCount, includeBrackets: false);
        string typeParameters         = parameterCount == 0 ? string.Empty : "<" + GetTypeParameters(parameterCount) + ">";
        string testArguments          = GetTestArguments(parameterCount);
        string optionalComma          = parameterCount > 0 ? ", " : string.Empty;

#>
    #region ReliableAction<#= typeParameters #>

    [TestClass]
    public sealed class ReliableActionTest<#= parameterCount > 0 ? parameterCount.ToString() : string.Empty #> : ReliableDelegateTest
    {
        private static readonly Func<ReliableAction<#= typeArguments #>, Action<#= typeArguments #>> s_getAction = DynamicGetter.ForField<ReliableAction<#= typeArguments #>, Action<#= typeArguments #>>("_action");

        [TestMethod]
        public void Ctor_DelayPolicy()
        {
            Assert.ThrowsException<ArgumentNullException      >(() => new ReliableAction<#= typeArguments #>(null, Retries.Infinite, ExceptionPolicies.Fatal, DelayPolicies.None));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => new ReliableAction<#= typeArguments #>((<#= arguments #>) => Console.WriteLine("Hello World"), -2            , ExceptionPolicies.Fatal, DelayPolicies.None));
            Assert.ThrowsException<ArgumentNullException      >(() => new ReliableAction<#= typeArguments #>((<#= arguments #>) => Console.WriteLine("Hello World"), Retries.Infinite, null                   , DelayPolicies.None));
            Assert.ThrowsException<ArgumentNullException      >(() => new ReliableAction<#= typeArguments #>((<#= arguments #>) => Console.WriteLine("Hello World"), Retries.Infinite, ExceptionPolicies.Fatal, (DelayPolicy)null ));

            Action<#= typeArguments #> action = (<#= arguments #>) => Console.WriteLine("Hello World");
            ReliableAction<#= typeArguments #> actual = new ReliableAction<#= typeArguments #>(action, 37, ExceptionPolicies.Transient, DelayPolicies.Constant(115));

            Assert.AreSame(action, s_getAction(actual));
            Ctor(actual, 37, ExceptionPolicies.Transient, actualPolicy =>
            {
                Assert.AreEqual(TimeSpan.FromMilliseconds(115), actualPolicy( 1, new Exception()));
                Assert.AreEqual(TimeSpan.FromMilliseconds(115), actualPolicy( 2, new Exception()));
                Assert.AreEqual(TimeSpan.FromMilliseconds(115), actualPolicy(10, new Exception()));
            });
        }

        [TestMethod]
        public void Ctor_ComplexDelayPolicy()
        {
            Assert.ThrowsException<ArgumentNullException      >(() => new ReliableAction<#= typeArguments #>(null, Retries.Infinite, ExceptionPolicies.Fatal, (i, e) => TimeSpan.Zero));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => new ReliableAction<#= typeArguments #>((<#= arguments #>) => Console.WriteLine("Hello World"), -2            , ExceptionPolicies.Fatal, (i, e) => TimeSpan.Zero ));
            Assert.ThrowsException<ArgumentNullException      >(() => new ReliableAction<#= typeArguments #>((<#= arguments #>) => Console.WriteLine("Hello World"), Retries.Infinite, null                   , (i, e) => TimeSpan.Zero ));
            Assert.ThrowsException<ArgumentNullException      >(() => new ReliableAction<#= typeArguments #>((<#= arguments #>) => Console.WriteLine("Hello World"), Retries.Infinite, ExceptionPolicies.Fatal, (ComplexDelayPolicy)null));

            ComplexDelayPolicy delayPolicy = (i, e) => TimeSpan.Zero;
            Action<#= typeArguments #> action = (<#= arguments #>) => Console.WriteLine("Hello World");
            ReliableAction<#= typeArguments #> actual = new ReliableAction<#= typeArguments #>(action, 37, ExceptionPolicies.Transient, delayPolicy);

            Assert.AreSame(action, s_getAction(actual));
            Ctor(actual, 37, ExceptionPolicies.Transient, delayPolicy);
        }

        [TestMethod]
        public void Invoke_NoCancellationToken()
            => Invoke((reliableAction<#= optionalComma #><#= arguments #>) => reliableAction.Invoke(<#= arguments #>));

        [TestMethod]
        public void Invoke_CancellationToken()
        {
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Invoke((reliableAction<#= optionalComma #><#= arguments #>) => reliableAction.Invoke(<#= arguments #><#= optionalComma #>tokenSource.Token));

            // Ensure CancellationToken prevents additional retry
            Invoke_Canceled((reliableAction<#= optionalComma #><#= arguments #>, token) => reliableAction.Invoke(<#= arguments #><#= optionalComma #>token));
        }

        [TestMethod]
        public void TryInvoke_NoCancellationToken()
            => TryInvoke((reliableAction<#= optionalComma #><#= arguments #>) => reliableAction.TryInvoke(<#= arguments #>));

        [TestMethod]
        public void TryInvoke_CancellationToken()
        {
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                TryInvoke((reliableAction<#= optionalComma #><#= arguments #>) => reliableAction.TryInvoke(<#= arguments #><#= optionalComma #>tokenSource.Token));
        
            // Ensure CancellationToken prevents additional retry
            Invoke_Canceled((reliableAction<#= optionalComma #><#= arguments #>, token) => reliableAction.TryInvoke(<#= arguments #><#= optionalComma #>token));
        }

        private void Invoke(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> invoke)
        {
            Invoke_Success        (invoke);
            Invoke_EventualSuccess(invoke);

            Invoke_Failure         <             InvalidOperationException>(GetFailureAssertion<InvalidOperationException>());
            Invoke_EventualFailure <IOException, InvalidOperationException>(GetFailureAssertion<InvalidOperationException>());
            Invoke_RetriesExhausted<IOException                           >(GetFailureAssertion<IOException              >());

            Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> GetFailureAssertion<T>()
                where T : Exception
            {
                return (r<#= optionalComma #><#= arguments #>) =>
                {
                    try
                    {
                        invoke(r<#= optionalComma #><#= arguments #>);
                        Assert.Fail();
                    }
                    catch (T)
                    { }
                    catch (Exception)
                    {
                        Assert.Fail();
                    }
                };
            }
        }

        private void TryInvoke(Func<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, bool> tryInvoke)
        {
            Invoke_Success                                                 ((r<#= optionalComma #><#= arguments #>) => Assert.IsTrue (tryInvoke(r<#= optionalComma #><#= arguments #>)));
            Invoke_EventualSuccess                                         ((r<#= optionalComma #><#= arguments #>) => Assert.IsTrue (tryInvoke(r<#= optionalComma #><#= arguments #>)));
            Invoke_Failure         <             InvalidOperationException>((r<#= optionalComma #><#= arguments #>) => Assert.IsFalse(tryInvoke(r<#= optionalComma #><#= arguments #>)));
            Invoke_EventualFailure <IOException, InvalidOperationException>((r<#= optionalComma #><#= arguments #>) => Assert.IsFalse(tryInvoke(r<#= optionalComma #><#= arguments #>)));
            Invoke_RetriesExhausted<IOException                           >((r<#= optionalComma #><#= arguments #>) => Assert.IsFalse(tryInvoke(r<#= optionalComma #><#= arguments #>)));
        }

        private void Invoke_Success(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> assertInvoke)
        {
            ObservableFunc<Exception, bool> exceptionPolicy = PolicyValidator.Create(ExceptionPolicies.Fatal);
            ObservableFunc<int, TimeSpan>   delayPolicy     = PolicyValidator.Create(DelayPolicies.None);

            ReliableAction<#= typeArguments #> reliableAction = new ReliableAction<#= typeArguments #>(
                (<#= arguments #>) => <#= parameterCount > 0 ? "AssertDelegateParameters(" + arguments + ")" : "Console.WriteLine(\"Success\")" #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            reliableAction.Retrying         += (i, e) => Assert.Fail();
            reliableAction.Failed           +=     e  => Assert.Fail();
            reliableAction.RetriesExhausted +=     e  => Assert.Fail();

            assertInvoke(reliableAction<#= optionalComma #><#= testArguments #>);

            Assert.AreEqual(0, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        private void Invoke_Failure<T>(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> assertInvoke)
            where T : Exception, new()
        {
            ObservableFunc<Exception, bool>          exceptionPolicy = PolicyValidator.Create<T>(ExceptionPolicies.Fail<T>());
            ObservableFunc<int, Exception, TimeSpan> delayPolicy     = PolicyValidator.Create<T>((i, e) => TimeSpan.Zero);

            ReliableAction<#= typeArguments #> reliableAction = new ReliableAction<#= typeArguments #>(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    AssertDelegateParameters(<#= arguments #>);
<#
        }
#>
                    throw new T();
                },
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            int failures = 0;
            reliableAction.Retrying         += (i, e) => Assert.Fail();
            reliableAction.RetriesExhausted +=     e  => Assert.Fail();
            reliableAction.Failed           +=     e  => { failures++; Assert.AreEqual(typeof(T), e.GetType()); };

            assertInvoke(reliableAction<#= optionalComma #><#= testArguments #>);

            Assert.AreEqual(1, failures);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        private void Invoke_EventualSuccess(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> assertInvoke)
        {
            ObservableFunc<Exception, bool> exceptionPolicy = PolicyValidator.Create<IOException>(ExceptionPolicies.Retry<IOException>());
            ObservableFunc<int, TimeSpan>   delayPolicy     = PolicyValidator.Create(DelayPolicies.None);

            Action eventualSuccess = FlakyAction.Create<IOException>(3);
            ReliableAction<#= typeArguments #> reliableAction = new ReliableAction<#= typeArguments #>(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    AssertDelegateParameters(<#= arguments #>);
<#
        }
#>
                    eventualSuccess();
                },
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            int retries = 0;
            reliableAction.Retrying         += (i, e) => { Assert.AreEqual(++retries, i); Assert.AreEqual(typeof(IOException), e.GetType()); };
            reliableAction.Failed           +=     e  => Assert.Fail();
            reliableAction.RetriesExhausted +=     e  => Assert.Fail();

            assertInvoke(reliableAction<#= optionalComma #><#= testArguments #>);

            Assert.AreEqual(3, retries);
            Assert.AreEqual(retries, exceptionPolicy.Calls);
            Assert.AreEqual(retries, delayPolicy    .Calls);
        }

        private void Invoke_EventualFailure<TTransient, TFatal>(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> assertInvoke)
            where TTransient : Exception, new()
            where TFatal     : Exception, new()
        {
            ObservableFunc<Exception, bool> exceptionPolicy = PolicyValidator.Create<TTransient, TFatal>(ExceptionPolicies.Retry<TTransient>());
            ObservableFunc<int, TimeSpan>   delayPolicy     = PolicyValidator.Create(DelayPolicies.None);

            Action eventualFailure = FlakyAction.Create<TTransient, TFatal>(4);
            ReliableAction<#= typeArguments #> reliableAction = new ReliableAction<#= typeArguments #>(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    AssertDelegateParameters(<#= arguments #>);
<#
        }
#>
                    eventualFailure();
                },
                5,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            int retries = 0, failures = 0;
            reliableAction.Retrying         += (i, e) => { Assert.AreEqual(++retries, i); Assert.AreEqual(typeof(TTransient), e.GetType()); };
            reliableAction.Failed           +=     e  => { failures++;                    Assert.AreEqual(typeof(TFatal    ), e.GetType()); };
            reliableAction.RetriesExhausted +=     e  => Assert.Fail();

            assertInvoke(reliableAction<#= optionalComma #><#= testArguments #>);

            Assert.AreEqual(4, retries );
            Assert.AreEqual(1, failures);
            Assert.AreEqual(retries + 1, exceptionPolicy.Calls);
            Assert.AreEqual(retries    , delayPolicy    .Calls);
        }

        private void Invoke_RetriesExhausted<T>(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> assertInvoke)
            where T : Exception, new()
        {
            ObservableFunc<Exception, bool> exceptionPolicy = PolicyValidator.Create<T>(ExceptionPolicies.Retry<T>());
            ObservableFunc<int, TimeSpan>   delayPolicy     = PolicyValidator.Create(DelayPolicies.None);

            ReliableAction<#= typeArguments #> reliableAction = new ReliableAction<#= typeArguments #>(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    AssertDelegateParameters(<#= arguments #>);
<#
        }
#>
                    throw new T();
                },
                5,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            int retries = 0, exhausted = 0;
            reliableAction.Retrying         += (i, e) => { Assert.AreEqual(++retries, i); Assert.AreEqual(typeof(T), e.GetType()); };
            reliableAction.Failed           +=     e  => Assert.Fail();
            reliableAction.RetriesExhausted +=     e  => { exhausted++; Assert.AreEqual(typeof(T), e.GetType()); };

            assertInvoke(reliableAction<#= optionalComma #><#= testArguments #>);

            Assert.AreEqual(5, retries  );
            Assert.AreEqual(1, exhausted);
            Assert.AreEqual(retries + 1, exceptionPolicy.Calls);
            Assert.AreEqual(retries    , delayPolicy    .Calls);
        }

        private void Invoke_Canceled(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> assertInvoke)
        {
            using ManualResetEvent        retryEvent  = new ManualResetEvent(false);
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            ObservableFunc<Exception, bool> exceptionPolicy = PolicyValidator.Create<IOException>(ExceptionPolicies.Retry<IOException>());
            ObservableFunc<int, TimeSpan>   delayPolicy     = PolicyValidator.Create(DelayPolicies.None);

            ReliableAction<#= typeArguments #> reliableAction = new ReliableAction<#= typeArguments #>(
                (<#= arguments #>) =>
                {
<#
        if (parameterCount > 0)
        {
#>
                    AssertDelegateParameters(<#= arguments #>);
<#
        }
#>
                    throw new IOException();
                },
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            int retries = 0;
            reliableAction.Retrying += (i, e) =>
            {
                Assert.AreEqual(++retries, i);
                Assert.AreEqual(typeof(IOException), e.GetType());
                retryEvent.Set();
            };
            reliableAction.Failed           += e => Assert.Fail();
            reliableAction.RetriesExhausted += e => Assert.Fail();

            // While waiting for the reliable action to complete, we'll cancel it
            Task invocation = Task.Run(() => assertInvoke(reliableAction<#= optionalComma #><#= testArguments #>, tokenSource.Token), tokenSource.Token);

            // Cancel after at least 1 retry has occurred
            retryEvent.WaitOne();
            tokenSource.Cancel();

            // Try to get the result
            try
            {
                invocation.Wait();
                Assert.Fail();
            }
            catch (AggregateException agg)
            {
                Assert.AreEqual(1, agg.InnerExceptions.Count);
                switch (agg.InnerException)
                {
                    case AssertFailedException afe:
                        throw afe;
                    case TaskCanceledException _:
                        Assert.IsTrue(retries > 0);
                        Assert.AreEqual(retries + 1, exceptionPolicy.Calls);
                        Assert.AreEqual(retries + 1, delayPolicy    .Calls);
                        return; // Successfully cancelled
                    default:
                        Assert.Fail();
                        break;
                }
            }
            catch (Exception)
            {
                Assert.Fail();
            }
        }
<#
        if (parameterCount > 0)
        {
#>

        private static void AssertDelegateParameters(<#= parameters #>)
        {
<#
            int maxArgLength = args.Take(parameterCount).Select(x => x.Length).Max();
            for (int i = 0; i < parameterCount; i++)
            {
#>
            Assert.AreEqual(<#= args[i].PadRight(maxArgLength) #>, <#= parameterCount == 1 ? "arg" : "arg" + (i + 1) #>);
<#
            }
#>
        }
<#
        }
#>
    }

    #endregion

<#
    }
#>
}
<#+
    static string[] typeArgs = new string[]
    {
        "int",
        "string",
        "double",
        "long",
        "ushort",
        "byte",
        "TimeSpan",
        "uint",
        "Tuple<bool, ulong>",
        "DateTime",
        "ulong",
        "sbyte",
        "decimal",
        "char",
        "float",
        "Guid",
    };

    static string[] args = new string[]
    {
        "42",
        "\"foo\"",
        "3.14D",
        "1000L",
        "(ushort)1",
        "(byte)255",
        "TimeSpan.FromDays(30)",
        "112U",
        "Tuple.Create(true, 64UL)",
        "new DateTime(2019, 10, 06)",
        "321UL",
        "(sbyte)-7",
        "-24.68M",
        "'!'",
        "0.1F",
        "Guid.Parse(\"53710ff0-eaa3-4fac-a068-e5be641d446b\")",
    };

    public string GetTypeArgs(int count, bool includeBrackets = true)
    {
        if (count == 0)
            return string.Empty;

        string result = string.Join(", ", typeArgs.Take(count));
        if (includeBrackets)
            result = "<" + result + ">";

        return result;
    }

    public string GetTestArguments(int count)
        => string.Join(", ", args.Take(count));
#>
