<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".tt.out" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="$(MSBuildProjectDirectory)\TextTemplating\Include.t4" #><#
    for (int parameterCount = 0; parameterCount <= MaxDelegateParameters; parameterCount++)
    {
        string optionalComma  = parameterCount > 0 ? ", " : string.Empty;
        string arguments      = GetArguments     (          parameterCount);
        string parameters     = GetParameters    (typeArgs, parameterCount);
        string argumentValues = GetArgumentValues(          parameterCount);
        string typeArguments  = GetTypeArguments (          parameterCount);
        string baseSuffix     = "T" + (parameterCount + 1);
#>
// Generated from <#= GetTemplateFileName() #>
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Sweetener.Reliability.Test
{
    // Define type aliases for the various generic types used below as they can become pretty cumbersome
    using TestAction                        = Action     <#= Enclose(GetTypeArguments(parameterCount, async: false, interruptable: false), BracketType.AngleBrackets) #>;
    using InterruptableTestAction           = Action     <#= Enclose(GetTypeArguments(parameterCount, async: false, interruptable: true ), BracketType.AngleBrackets) #>;
    using AsyncTestAction                   = Func       <#= Enclose(GetTypeArguments(parameterCount, async: true , interruptable: false), BracketType.AngleBrackets) #>;
    using InterruptableAsyncTestAction      = Func       <#= Enclose(GetTypeArguments(parameterCount, async: true , interruptable: true ), BracketType.AngleBrackets) #>;
    using TestActionProxy                   = ActionProxy<#= Enclose(GetTypeArguments(parameterCount, async: false, interruptable: false), BracketType.AngleBrackets) #>;
    using InterruptableTestActionProxy      = ActionProxy<#= Enclose(GetTypeArguments(parameterCount, async: false, interruptable: true ), BracketType.AngleBrackets) #>;
    using AsyncTestActionProxy              = FuncProxy  <#= Enclose(GetTypeArguments(parameterCount, async: true , interruptable: false), BracketType.AngleBrackets) #>;
    using InterruptableAsyncTestActionProxy = FuncProxy  <#= Enclose(GetTypeArguments(parameterCount, async: true , interruptable: true ), BracketType.AngleBrackets) #>;
    using DelayPolicyProxy                  = FuncProxy<int, TimeSpan>;
    using ComplexDelayPolicyProxy           = FuncProxy<int, Exception, TimeSpan>;

<#
        if (parameterCount == 0)
        {
#>
    [TestClass]
    public partial class ActionExtensionsTest
<#
        }
        else
        {
#>
    partial class ActionExtensionsTest
<#
        }
#>
    {
<#
        foreach (bool async in new bool[] { false, true })
        {
            foreach (bool interruptable in new bool[] { false, true })
            {
                string inputTypeArguments = Enclose(GetTypeArguments(parameterCount, async: false, interruptable: interruptable), BracketType.AngleBrackets);
                string optionalToken      = interruptable ?                 "token" : "CancellationToken.None";
                string optionalCommaToken = interruptable ? optionalComma + "token" : string.Empty;

                foreach (bool useComplexPolicy in new bool[] { false, true })
                {
                    string inputActionType      = (interruptable ? "Interruptable" : string.Empty) + (async ? "Async" : string.Empty) + "TestAction";
                    string delayPolicyFunc      = useComplexPolicy ? "Func<int, Exception, TimeSpan>" : "Func<int, TimeSpan>";
                    string delayPolicyTypeProxy = (useComplexPolicy ? "ComplexDelayPolicy" : "DelayPolicy") + "Proxy";
                    string noDelayPolicy        = useComplexPolicy ? "(i, e) => TimeSpan.Zero" : "DelayPolicies.None";
                    string testSuffix           = baseSuffix + (async ? "_Async" : string.Empty) + (interruptable ? "_WithToken" : string.Empty) +  "_" + (useComplexPolicy ? "ComplexDelayPolicy" : "DelayPolicy");
#>
        [TestMethod]
        public void WithRetry<#= testSuffix #>()
        {
            <#= inputActionType #> nullAction = null;
            <#= inputActionType #> action     = <#= GetNoOpDelegate(parameterCount, async, interruptable) #>;
            Assert.ThrowsException<ArgumentNullException      >(() => nullAction.WithRetry( 4, ExceptionPolicies.Transient, <#= noDelayPolicy #>));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => action    .WithRetry(-2, ExceptionPolicies.Transient, <#= noDelayPolicy #>));
            Assert.ThrowsException<ArgumentNullException      >(() => action    .WithRetry( 4, null                       , <#= noDelayPolicy #>));
            Assert.ThrowsException<ArgumentNullException      >(() => action    .WithRetry( 4, ExceptionPolicies.Transient, (<#= useComplexPolicy ? "Complex" : string.Empty #>DelayPolicy)null));

            // Create the delegates necessary to test the WithRetry overload
            Func<Action<CancellationToken>, <#= inputActionType #>Proxy> actionFactory = a => new <#= inputActionType #>Proxy(<#= async ? "async " : string.Empty #>(<#= arguments #><#= optionalCommaToken #>) => <#= async ? $"{{ await Task.CompletedTask.ConfigureAwait(false); a({optionalToken}); }}" : $"a({optionalToken})" #>);
            Func<TimeSpan, <#= delayPolicyTypeProxy #>> delayPolicyFactory = t => new <#= delayPolicyTypeProxy #>((i<#= useComplexPolicy ? ", e" : string.Empty #>) => t);
            Func<<#=inputActionType #>, int, ExceptionPolicy, <#= delayPolicyFunc #>, <#= inputActionType #>> withRetry = (a, r, e, d) => a.WithRetry(r, e, d.Invoke);
            Action<<#= inputActionType #><#= optionalComma #><#= typeArguments #>, CancellationToken> invoke = (action<#= optionalComma #><#= arguments #>, token) => action(<#= arguments #><#= optionalCommaToken #>)<#= async ? ".Wait()" : string.Empty #>;

            Action<<#= inputActionType #>Proxy>           observeAction      = <#= interruptable || parameterCount > 0 ? $"a          => a.Invoking += Expect.Arguments{inputTypeArguments}(Arguments.Validate)" : "null" #>;
            Action<<#= inputActionType #>Proxy, TimeSpan> observeActionDelay = (a, delay) => a.Invoking += Expect.<#= interruptable || parameterCount > 0 ? $"ArgumentsAfterDelay{inputTypeArguments}(Arguments.Validate, delay)" : $"AfterDelay{inputTypeArguments}(delay)" #>;

            // Test each scenario
            WithRetry<#= baseSuffix #>_Success         (actionFactory, delayPolicyFactory, withRetry, invoke, observeAction     ,  d     => d.Invoking += Expect.Nothing<int<#= useComplexPolicy ? ", Exception" : string.Empty #>>());
            WithRetry<#= baseSuffix #>_Failure         (actionFactory, delayPolicyFactory, withRetry, invoke, observeAction     ,  d     => d.Invoking += Expect.Nothing<int<#= useComplexPolicy ? ", Exception" : string.Empty #>>());
            WithRetry<#= baseSuffix #>_EventualSuccess (actionFactory, delayPolicyFactory, withRetry, invoke, observeActionDelay, (d, e) => d.Invoking += Expect.<#= useComplexPolicy ? "ExceptionAsc(e)" : "Asc()" #>);
            WithRetry<#= baseSuffix #>_EventualFailure (actionFactory, delayPolicyFactory, withRetry, invoke, observeActionDelay, (d, e) => d.Invoking += Expect.<#= useComplexPolicy ? "ExceptionAsc(e)" : "Asc()" #>);
            WithRetry<#= baseSuffix #>_RetriesExhausted(actionFactory, delayPolicyFactory, withRetry, invoke, observeActionDelay, (d, e) => d.Invoking += Expect.<#= useComplexPolicy ? "ExceptionAsc(e)" : "Asc()" #>);
<#
        if (interruptable)
        {
#>
            WithRetry<#= baseSuffix #>_Canceled_Action (actionFactory, delayPolicyFactory, withRetry, invoke, observeActionDelay, (d, e) => d.Invoking += Expect.<#= useComplexPolicy ? "ExceptionAsc(e)" : "Asc()" #>);
<#
        }
#>
            WithRetry<#= baseSuffix #>_Canceled_Delay  (actionFactory, delayPolicyFactory, withRetry, invoke, observeActionDelay, (d, e) => d.Invoking += Expect.<#= useComplexPolicy ? "ExceptionAsc(e)" : "Asc()" #>);
        }

<#
                }
            }
        }
#>
        #region WithRetry<#= baseSuffix #>_Success

        private void WithRetry<#= baseSuffix #>_Success<TAction, TDelayPolicy, TActionProxy, TDelayPolicyProxy>(
            Func<Action<CancellationToken>, TActionProxy> actionFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TAction, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArguments #>, CancellationToken> invoke,
            Action<TActionProxy> observeAction,
            Action<TDelayPolicyProxy> observeDelayPolicy)
            where TAction           : Delegate
            where TDelayPolicy      : Delegate
            where TActionProxy      : DelegateProxy<TAction>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create a "successful" user-defined action
            TActionProxy action = actionFactory(t => Operation.Null());

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>();
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(TimeSpan.Zero);

            // Create the reliable action
            TAction reliableAction = withRetry(
                action.Proxy,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            observeAction?.Invoke(action);
            exceptionPolicy.Invoking += Expect.Nothing<Exception>();
            observeDelayPolicy?.Invoke(delayPolicy);

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                invoke(reliableAction<#= optionalComma #><#= argumentValues #>, tokenSource.Token);

            // Validate the number of calls
            Assert.AreEqual(1, action         .Calls);
            Assert.AreEqual(0, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_Failure

        private void WithRetry<#= baseSuffix #>_Failure<TAction, TDelayPolicy, TActionProxy, TDelayPolicyProxy>(
            Func<Action<CancellationToken>, TActionProxy> actionFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TAction, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArguments #>, CancellationToken> invoke,
            Action<TActionProxy> observeAction,
            Action<TDelayPolicyProxy> observeDelayPolicy)
            where TAction           : Delegate
            where TDelayPolicy      : Delegate
            where TActionProxy      : DelegateProxy<TAction>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create an "unsuccessful" user-defined action
            TActionProxy action = actionFactory(t => throw new InvalidOperationException());

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Fail<InvalidOperationException>().Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(TimeSpan.Zero);

            // Create the reliable action
            TAction reliableAction = withRetry(
                action.Proxy,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            observeAction?.Invoke(action);
            exceptionPolicy.Invoking += Expect.Exception(typeof(InvalidOperationException));
            observeDelayPolicy?.Invoke(delayPolicy);

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.That.ThrowsException<InvalidOperationException>(() => invoke(reliableAction<#= optionalComma #><#= argumentValues #>, tokenSource.Token));

            // Validate the number of calls
            Assert.AreEqual(1, action         .Calls);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_EventualSuccess

        private void WithRetry<#= baseSuffix #>_EventualSuccess<TAction, TDelayPolicy, TActionProxy, TDelayPolicyProxy>(
            Func<Action<CancellationToken>, TActionProxy> actionFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TAction, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArguments #>, CancellationToken> invoke,
            Action<TActionProxy, TimeSpan> observeAction,
            Action<TDelayPolicyProxy, Type> observeDelayPolicy)
            where TAction           : Delegate
            where TDelayPolicy      : Delegate
            where TActionProxy      : DelegateProxy<TAction>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create a "successful" user-defined action that completes after 1 IOException
            Action flakyAction = FlakyAction.Create<IOException>(1);
            TActionProxy action = actionFactory(t => flakyAction());

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(Constants.Delay);

            // Create the reliable action
            TAction reliableAction = withRetry(
                action.Proxy,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            observeAction?.Invoke(action, Constants.MinDelay);
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));
            observeDelayPolicy?.Invoke(delayPolicy, typeof(IOException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                invoke(reliableAction<#= optionalComma #><#= argumentValues #>, tokenSource.Token);

            // Validate the number of calls
            Assert.AreEqual(2, action         .Calls);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(1, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_EventualFailure

        private void WithRetry<#= baseSuffix #>_EventualFailure<TAction, TDelayPolicy, TActionProxy, TDelayPolicyProxy>(
            Func<Action<CancellationToken>, TActionProxy> actionFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TAction, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArguments #>, CancellationToken> invoke,
            Action<TActionProxy, TimeSpan> observeAction,
            Action<TDelayPolicyProxy, Type> observeDelayPolicy)
            where TAction           : Delegate
            where TDelayPolicy      : Delegate
            where TActionProxy      : DelegateProxy<TAction>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create an "unsuccessful" user-defined action that fails after 2 transient exceptions
            Action flakyAction = FlakyAction.Create<IOException, InvalidOperationException>(2);
            TActionProxy action = actionFactory(t => flakyAction());

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(Constants.Delay);

            // Create the reliable action
            TAction reliableAction = withRetry(
                action.Proxy,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            observeAction?.Invoke(action, Constants.MinDelay);
            exceptionPolicy.Invoking += Expect.Exceptions(typeof(IOException), typeof(InvalidOperationException), 2);
            observeDelayPolicy?.Invoke(delayPolicy, typeof(IOException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.That.ThrowsException<InvalidOperationException>(() => invoke(reliableAction<#= optionalComma #><#= argumentValues #>, tokenSource.Token));

            // Validate the number of calls
            Assert.AreEqual(3, action          .Calls);
            Assert.AreEqual(3, exceptionPolicy .Calls);
            Assert.AreEqual(2, delayPolicy     .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_RetriesExhausted

        private void WithRetry<#= baseSuffix #>_RetriesExhausted<TAction, TDelayPolicy, TActionProxy, TDelayPolicyProxy>(
            Func<Action<CancellationToken>, TActionProxy> actionFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TAction, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArguments #>, CancellationToken> invoke,
            Action<TActionProxy, TimeSpan> observeAction,
            Action<TDelayPolicyProxy, Type> observeDelayPolicy)
            where TAction           : Delegate
            where TDelayPolicy      : Delegate
            where TActionProxy      : DelegateProxy<TAction>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create an "unsuccessful" user-defined action that exhausts the configured number of retries
            TActionProxy action = actionFactory(t => throw new IOException());

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(Constants.Delay);

            // Create the reliable action
            TAction reliableAction = withRetry(
                action.Proxy,
                2,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            observeAction?.Invoke(action, Constants.MinDelay);
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));
            observeDelayPolicy?.Invoke(delayPolicy, typeof(IOException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.That.ThrowsException<IOException>(() => invoke(reliableAction<#= optionalComma #><#= argumentValues #>, tokenSource.Token));

            // Validate the number of calls
            Assert.AreEqual(3, action          .Calls);
            Assert.AreEqual(3, exceptionPolicy .Calls);
            Assert.AreEqual(2, delayPolicy     .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_Canceled_Action

        private void WithRetry<#= baseSuffix #>_Canceled_Action<TAction, TDelayPolicy, TActionProxy, TDelayPolicyProxy>(
            Func<Action<CancellationToken>, TActionProxy> actionFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TAction, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArguments #>, CancellationToken> invoke,
            Action<TActionProxy, TimeSpan> observeAction,
            Action<TDelayPolicyProxy, Type> observeDelayPolicy)
            where TAction           : Delegate
            where TDelayPolicy      : Delegate
            where TActionProxy      : DelegateProxy<TAction>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            // Create a user-defined action that will throw an exception depending on whether its canceled
            TActionProxy action = actionFactory(t =>
            {
                t.ThrowIfCancellationRequested();
                throw new IOException();
            });

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(Constants.Delay);

            // Create the reliable action
            TAction reliableAction = withRetry(
                action.Proxy,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            observeAction?.Invoke(action, Constants.MinDelay);
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));
            observeDelayPolicy?.Invoke(delayPolicy, typeof(IOException));

            // Cancel the action on its 2nd attempt
            action.Invoking += c =>
            {
                if (c.Calls == 2)
                    tokenSource.Cancel();
            };

            // Invoke
            Assert.That.ThrowsException<OperationCanceledException>(() => invoke(reliableAction<#= optionalComma #><#= argumentValues #>, tokenSource.Token), allowedDerivedTypes: true);

            // Validate the number of calls
            Assert.AreEqual(2, action         .Calls);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(1, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_Canceled_Delay

        private void WithRetry<#= baseSuffix #>_Canceled_Delay<TAction, TDelayPolicy, TActionProxy, TDelayPolicyProxy>(
            Func<Action<CancellationToken>, TActionProxy> actionFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TAction, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArguments #>, CancellationToken> invoke,
            Action<TActionProxy, TimeSpan> observeAction,
            Action<TDelayPolicyProxy, Type> observeDelayPolicy)
            where TAction           : Delegate
            where TDelayPolicy      : Delegate
            where TActionProxy      : DelegateProxy<TAction>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            // Create an "unsuccessful" user-defined action that continues to fail with transient exceptions until it's canceled
            TActionProxy action = actionFactory(t => throw new IOException());

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(Constants.Delay);

            // Create the reliable InterruptableAction
            TAction reliableAction = withRetry(
                action.Proxy,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            observeAction?.Invoke(action, Constants.MinDelay);
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));
            observeDelayPolicy?.Invoke(delayPolicy, typeof(IOException));

            // Cancel the delay on its 2nd invocation
            delayPolicy.Invoking += c =>
            {
                if (c.Calls == 2)
                    tokenSource.Cancel();
            };

            // Begin the invocation
            Assert.That.ThrowsException<OperationCanceledException>(() => invoke(reliableAction<#= optionalComma #><#= argumentValues #>, tokenSource.Token), allowedDerivedTypes: true);

            // Validate the number of calls
            Assert.AreEqual(2, action         .Calls);
            Assert.AreEqual(2, exceptionPolicy.Calls);
            Assert.AreEqual(2, delayPolicy    .Calls);
        }

        #endregion
    }
}
<#
        string fileName = parameterCount == 0 ? "Action.Extensions.Test.cs" : $"Action.Extensions.T{parameterCount}.Test.cs";
        SaveOutput(fileName);
    }
#>
<#= GetTemplateFileName() #> ran successfully
