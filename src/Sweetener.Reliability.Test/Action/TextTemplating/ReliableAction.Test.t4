<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".tt.out" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="$(MSBuildProjectDirectory)\TextTemplating\Include.t4" #><#
    // Assume a boolean variable called "async" has been previously defined!
    string optionalAsync = async ? "Async" : string.Empty;

    for (int parameterCount = 0; parameterCount <= MaxDelegateParameters; parameterCount++)
    {
        string optionalComma           = parameterCount > 0 ? ", " : string.Empty;
        string arguments               = GetArguments     (          parameterCount);
        string parameters              = GetParameters    (typeArgs, parameterCount);
        string argumentValues          = GetArgumentValues(          parameterCount);
        string typeArgumentsNoBrackets = GetTypeArguments (          parameterCount);
        string typeArguments           = Enclose(typeArgumentsNoBrackets, BracketType.AngleBrackets);

        string inputActionKind               = (async ? "Func" : "Action");
        string inputActionTypeArguments      = Enclose(GetTypeArguments(parameterCount, async, interruptable: false), BracketType.AngleBrackets);
        string tokenInputActionTypeArguments = Enclose(GetTypeArguments(parameterCount, async, interruptable: true ), BracketType.AngleBrackets);
#>
// Generated from <#= GetTemplateFileName() #>
using System;
using System.IO;
using System.Threading;
<#
        if (async)
        {
#>
using System.Threading.Tasks;
<#
        }
#>
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Sweetener.Reflection;

namespace Sweetener.Reliability.Test
{
    [TestClass]
    public sealed class Reliable<#= optionalAsync #>Action<#= parameterCount > 0 ? parameterCount.ToString() : string.Empty #>Test : ReliableDelegateTest
    {
        private static readonly Func<Reliable<#= optionalAsync #>Action<#= typeArguments #>, <#= inputActionKind #><#= tokenInputActionTypeArguments #>> s_getAction = DynamicGetter.ForField<Reliable<#= optionalAsync #>Action<#= typeArguments #>, <#= inputActionKind #><#= tokenInputActionTypeArguments #>>("_action");

        [TestMethod]
        public void Ctor_DelayHandler()
            => Ctor_DelayHandler((a, m, d, e) => new Reliable<#= optionalAsync #>Action<#= typeArguments #>(a, m, d, e));

        [TestMethod]
        public void Ctor_ComplexDelayHandler()
            => Ctor_ComplexDelayHandler((a, m, d, e) => new Reliable<#= optionalAsync #>Action<#= typeArguments #>(a, m, d, e));

        [TestMethod]
        public void Ctor_Interruptable_DelayHandler()
            => Ctor_Interruptable_DelayHandler((a, m, d, e) => new Reliable<#= optionalAsync #>Action<#= typeArguments #>(a, m, d, e));

        [TestMethod]
        public void Ctor_Interruptable_ComplexDelayHandler()
            => Ctor_Interruptable_ComplexDelayHandler((a, m, d, e) => new Reliable<#= optionalAsync #>Action<#= typeArguments #>(a, m, d, e));

        [TestMethod]
        public void Create_DelayHandler()
            => Ctor_DelayHandler((a, m, d, e) => Reliable<#= optionalAsync #>Action.Create(a, m, d, e));

        [TestMethod]
        public void Create_ComplexDelayHandler()
            => Ctor_ComplexDelayHandler((a, m, d, e) => Reliable<#= optionalAsync #>Action.Create(a, m, d, e));

        [TestMethod]
        public void Create_Interruptable_DelayHandler()
            => Ctor_Interruptable_DelayHandler((a, m, d, e) => Reliable<#= optionalAsync #>Action.Create(a, m, d, e));

        [TestMethod]
        public void Create_Interruptable_ComplexDelayHandler()
            => Ctor_Interruptable_ComplexDelayHandler((a, m, d, e) => Reliable<#= optionalAsync #>Action.Create(a, m, d, e));

<#
        if (!async)
        {
#>
        [TestMethod]
        public void Invoke()
            => Invoke(passToken: false);

        [TestMethod]
        public void Invoke_CancellationToken()
            => Invoke(passToken: true);

<#
        }
#>
        [TestMethod]
        public void InvokeAsync()
            => InvokeAsync(passToken: false);

        [TestMethod]
        public void InvokeAsync_CancellationToken()
            => InvokeAsync(passToken: true);

<#
        if (!async)
        {
#>
        [TestMethod]
        public void TryInvoke()
            => TryInvoke(passToken: false);

        [TestMethod]
        public void TryInvoke_CancellationToken()
            => TryInvoke(passToken: true);

<#
        }
#>
        [TestMethod]
        public void TryInvokeAsync()
            => TryInvokeAsync(passToken: false);

        [TestMethod]
        public void TryInvokeAsync_CancellationToken()
            => TryInvokeAsync(passToken: true);

        #region Ctor

<#
        foreach (bool interruptable in new bool[] { false, true })
        {
            string ctorInputTypeArguments = interruptable  ? tokenInputActionTypeArguments : inputActionTypeArguments;
            string optionalActionInvoke   = !interruptable ? ".Invoke"                     : string.Empty;
            string optionalProxy          = !interruptable ? "Proxy"                       : string.Empty;

            foreach (bool useComplexHandler in new bool[] { false, true })
            {
                string delayHandlerType      = useComplexHandler  ? "ComplexDelayHandler" : "DelayHandler";
                string optionalHandlerInvoke = !useComplexHandler ? ".Invoke"             : string.Empty;
                string testName              = "Ctor" + (interruptable ? "_Interruptable" : string.Empty) + "_" + delayHandlerType;
#>
        private void <#= testName #>(Func<<#= inputActionKind #><#= ctorInputTypeArguments #>, int, ExceptionHandler, <#= delayHandlerType #>, Reliable<#= optionalAsync #>Action<#= typeArguments #>> factory)
        {
            <#= inputActionKind #><#= optionalProxy #><#= ctorInputTypeArguments #> action = <#= interruptable ? GetNoOpDelegate(parameterCount, async, interruptable: true) : $"new {inputActionKind}{optionalProxy}{ctorInputTypeArguments}()" #>;
            ExceptionHandler exceptionHandler = ExceptionPolicy.Fatal;
<#
                if (useComplexHandler)
                {
#>
            ComplexDelayHandler delayHandler = (i, e) => TimeSpan.FromHours(1);
<#
                }
                else
                {
#>
            FuncProxy<int, TimeSpan> delayHandler = new FuncProxy<int, TimeSpan>(i => Constants.Delay);
<#
                }
#>
            Assert.ThrowsException<ArgumentNullException      >(() => factory(null, Retries.Infinite, exceptionHandler, delayHandler<#= optionalHandlerInvoke #>));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => factory(action<#= optionalActionInvoke #>, -2              , exceptionHandler, delayHandler<#= optionalHandlerInvoke #>));
            Assert.ThrowsException<ArgumentNullException      >(() => factory(action<#= optionalActionInvoke #>, Retries.Infinite, null            , delayHandler<#= optionalHandlerInvoke #>));
            Assert.ThrowsException<ArgumentNullException      >(() => factory(action<#= optionalActionInvoke #>, Retries.Infinite, exceptionHandler, null));

            // Create a Reliable<#= optionalAsync #>Action and validate
            Reliable<#= optionalAsync #>Action<#= typeArguments #> actual = factory(action<#= optionalActionInvoke #>, 37, exceptionHandler, delayHandler<#= optionalHandlerInvoke #>);

            Ctor(actual, 37, exceptionHandler, delayHandler);
            CtorAction(actual, action);
        }

<#
            }
        }
#>
        private void CtorAction(Reliable<#= optionalAsync #>Action<#= typeArguments #> reliableAction, <#= inputActionKind #>Proxy<#= inputActionTypeArguments #> expected)
            => CtorAction(reliableAction, actual =>
            {
<#
        if (parameterCount > 0)
        {
#>
                expected.Invoking += Expect.Arguments<#= typeArguments #>(Arguments.Validate);

<#
        }
#>
                Assert.AreEqual(0, expected.Calls);
                actual(<#= argumentValues #><#= optionalComma #>default);
                Assert.AreEqual(1, expected.Calls);
            });

        private void CtorAction(Reliable<#= optionalAsync #>Action<#= typeArguments #> reliableAction, <#= inputActionKind #><#= tokenInputActionTypeArguments #> expected)
            => CtorAction(reliableAction, (<#= inputActionKind #><#= tokenInputActionTypeArguments #> actual) => Assert.AreSame(expected, actual));

        private void CtorAction(Reliable<#= optionalAsync #>Action<#= typeArguments #> reliableAction, Action<<#= inputActionKind #><#= tokenInputActionTypeArguments #>> validateAction)
            => validateAction(s_getAction(reliableAction));

        #endregion

<#
        if (!async)
        {
#>
        #region Invoke

        private void Invoke(bool passToken)
        {
            Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBrackets #>, CancellationToken> invoke;
            if (passToken)
                invoke = (r<#= optionalComma #><#= arguments #>, t) => r.Invoke(<#= arguments #><#= optionalComma #>t);
            else
                invoke = (r<#= optionalComma #><#= arguments #>, t) => r.Invoke(<#= arguments #>);

            // Callers may optionally include event handlers
            foreach (bool addEventHandlers in new bool[] { false, true })
            {
                Invoke_Success        (invoke, addEventHandlers);
                Invoke_EventualSuccess(invoke, addEventHandlers);

                Invoke_Failure         ((r<#= optionalComma #><#= arguments #>, t, e) => Assert.That.ThrowsException(() => invoke(r<#= optionalComma #><#= arguments #>, t), e), addEventHandlers);
                Invoke_EventualFailure ((r<#= optionalComma #><#= arguments #>, t, e) => Assert.That.ThrowsException(() => invoke(r<#= optionalComma #><#= arguments #>, t), e), addEventHandlers);
                Invoke_RetriesExhausted((r<#= optionalComma #><#= arguments #>, t, e) => Assert.That.ThrowsException(() => invoke(r<#= optionalComma #><#= arguments #>, t), e), addEventHandlers);

                if (passToken)
                {
                    Invoke_Canceled_Action(invoke, addEventHandlers);
                    Invoke_Canceled_Delay (invoke, addEventHandlers);
                }
            }
        }

        #endregion

<#
        }
#>
        #region InvokeAsync

        private void InvokeAsync(bool passToken)
        {
            Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBrackets #>, CancellationToken> invokeAsync;
            if (passToken)
                invokeAsync = (r<#= optionalComma #><#= arguments #>, t) => r.InvokeAsync(<#= arguments #><#= optionalComma #>t).Wait();
            else
                invokeAsync = (r<#= optionalComma #><#= arguments #>, t) => r.InvokeAsync(<#= arguments #>).Wait();

<#
        if (async)
        {
#>
            // Test an action that returns a null Task
            ReliableAsyncAction<#= typeArguments #> badAction = new ReliableAsyncAction<#= typeArguments #>((<#= arguments #>) => null, Retries.Infinite, ExceptionPolicy.Transient, DelayPolicy.None);
            Assert.That.ThrowsException<InvalidOperationException>(() => invokeAsync(badAction<#= optionalComma #><#= argumentValues #>, CancellationToken.None));

<#
        }
#>
            // Callers may optionally include event handlers
            foreach (bool addEventHandlers in new bool[] { false, true })
            {
                Invoke_Success        (invokeAsync, addEventHandlers);
                Invoke_EventualSuccess(invokeAsync, addEventHandlers);

                Invoke_Failure         ((r<#= optionalComma #><#= arguments #>, t, e) => Assert.That.ThrowsException(() => invokeAsync(r<#= optionalComma #><#= arguments #>, t), e), addEventHandlers);
                Invoke_EventualFailure ((r<#= optionalComma #><#= arguments #>, t, e) => Assert.That.ThrowsException(() => invokeAsync(r<#= optionalComma #><#= arguments #>, t), e), addEventHandlers);
                Invoke_RetriesExhausted((r<#= optionalComma #><#= arguments #>, t, e) => Assert.That.ThrowsException(() => invokeAsync(r<#= optionalComma #><#= arguments #>, t), e), addEventHandlers);

                if (passToken)
                {
<#
        if (async)
        {
#>
                    Invoke_Canceled_Action(invokeAsync, addEventHandlers, useSynchronousAction: false);
                    Invoke_Canceled_Action(invokeAsync, addEventHandlers, useSynchronousAction: true );
<#
        }
        else
        {
#>
                    Invoke_Canceled_Action(invokeAsync, addEventHandlers);
<#
        }
#>
                    Invoke_Canceled_Delay (invokeAsync, addEventHandlers);
                }
            }
        }

        #endregion

<#
        if (!async)
        {
#>
        #region TryInvoke

        private void TryInvoke(bool passToken)
        {
            Func<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBrackets #>, CancellationToken, bool> tryInvoke;
            if (passToken)
                tryInvoke = (r<#= optionalComma #><#= arguments #>, t) => r.TryInvoke(<#= arguments #><#= optionalComma #>t);
            else
                tryInvoke = (r<#= optionalComma #><#= arguments #>, t) => r.TryInvoke(<#= arguments #>);

            // Callers may optionally include event handlers
            foreach (bool addEventHandlers in new bool[] { false, true })
            {
                Invoke_Success         ((r<#= optionalComma #><#= arguments #>, t   ) => Assert.IsTrue (tryInvoke(r<#= optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_EventualSuccess ((r<#= optionalComma #><#= arguments #>, t   ) => Assert.IsTrue (tryInvoke(r<#= optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_Failure         ((r<#= optionalComma #><#= arguments #>, t, e) => Assert.IsFalse(tryInvoke(r<#= optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_EventualFailure ((r<#= optionalComma #><#= arguments #>, t, e) => Assert.IsFalse(tryInvoke(r<#= optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_RetriesExhausted((r<#= optionalComma #><#= arguments #>, t, e) => Assert.IsFalse(tryInvoke(r<#= optionalComma #><#= arguments #>, t)), addEventHandlers);

                if (passToken)
                {
                    Invoke_Canceled_Action((r<#= optionalComma #><#= arguments #>, t) => r.TryInvoke(<#= arguments #><#= optionalComma #>t), addEventHandlers);
                    Invoke_Canceled_Delay ((r<#= optionalComma #><#= arguments #>, t) => r.TryInvoke(<#= arguments #><#= optionalComma #>t), addEventHandlers);
                }
            }
        }

        #endregion

<#
        }
#>
        #region TryInvokeAsync

        private void TryInvokeAsync(bool passToken)
        {
            Func<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBrackets #>, CancellationToken, bool> tryInvokeAsync;
            if (passToken)
                tryInvokeAsync = (r<#= optionalComma #><#= arguments #>, t) => r.TryInvokeAsync(<#= arguments #><#= optionalComma #>t).Result;
            else
                tryInvokeAsync = (r<#= optionalComma #><#= arguments #>, t) => r.TryInvokeAsync(<#= arguments #>).Result;

<#
        if (async)
        {
#>
            // Test an action that returns a null Task
            ReliableAsyncAction<#= typeArguments #> badAction = new ReliableAsyncAction<#= typeArguments #>((<#= arguments #>) => null, Retries.Infinite, ExceptionPolicy.Transient, DelayPolicy.None);
            Assert.That.ThrowsException<InvalidOperationException>(() => tryInvokeAsync(badAction<#= optionalComma #><#= argumentValues #>, CancellationToken.None));

<#
        }
#>
            // Callers may optionally include event handlers
            foreach (bool addEventHandlers in new bool[] { false, true })
            {
                Invoke_Success         ((r<#= optionalComma #><#= arguments #>, t   ) => Assert.IsTrue (tryInvokeAsync(r<#= optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_EventualSuccess ((r<#= optionalComma #><#= arguments #>, t   ) => Assert.IsTrue (tryInvokeAsync(r<#= optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_Failure         ((r<#= optionalComma #><#= arguments #>, t, e) => Assert.IsFalse(tryInvokeAsync(r<#= optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_EventualFailure ((r<#= optionalComma #><#= arguments #>, t, e) => Assert.IsFalse(tryInvokeAsync(r<#= optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_RetriesExhausted((r<#= optionalComma #><#= arguments #>, t, e) => Assert.IsFalse(tryInvokeAsync(r<#= optionalComma #><#= arguments #>, t)), addEventHandlers);

                if (passToken)
                {
<#
        if (async)
        {
#>
                    Invoke_Canceled_Action((r<#= optionalComma #><#= arguments #>, t) => r.TryInvokeAsync(<#= arguments #><#= optionalComma #>t).Wait(), addEventHandlers, useSynchronousAction: false);
                    Invoke_Canceled_Action((r<#= optionalComma #><#= arguments #>, t) => r.TryInvokeAsync(<#= arguments #><#= optionalComma #>t).Wait(), addEventHandlers, useSynchronousAction: true );
<#
        }
        else
        {
#>
                    Invoke_Canceled_Action((r<#= optionalComma #><#= arguments #>, t) => r.TryInvokeAsync(<#= arguments #><#= optionalComma #>t).Wait(), addEventHandlers);
<#
        }
#>
                    Invoke_Canceled_Delay ((r<#= optionalComma #><#= arguments #>, t) => r.TryInvokeAsync(<#= arguments #><#= optionalComma #>t).Wait(), addEventHandlers);
                }
            }
        }

        #endregion

        #region Invoke_Success

        private void Invoke_Success(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBrackets #>, CancellationToken> assertInvoke, bool addEventHandlers)
        {
            // Create a "successful" user-defined action
            <#= inputActionKind #>Proxy<#= inputActionTypeArguments #> action = new <#= inputActionKind #>Proxy<#= inputActionTypeArguments #>(<#= GetNoOpDelegate(parameterCount, async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<Exception, bool>          exceptionHandler  = new FuncProxy<Exception, bool>();
            FuncProxy<int, Exception, TimeSpan> delayHandler      = new FuncProxy<int, Exception, TimeSpan>();

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke,
                Retries.Infinite,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action          .Invoking += Expect.Arguments<#= typeArguments #>(Arguments.Validate);
<#
        }
#>
            exceptionHandler.Invoking += Expect.Nothing<Exception>();
            delayHandler    .Invoking += Expect.Nothing<int, Exception>();
            retryHandler    .Invoking += Expect.Nothing<int, Exception>();
            failedHandler   .Invoking += Expect.Nothing<Exception>();
            exhaustedHandler.Invoking += Expect.Nothing<Exception>();

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= argumentValues #>, tokenSource.Token);

            // Validate the number of calls
            Assert.AreEqual(1, action          .Calls);
            Assert.AreEqual(0, exceptionHandler.Calls);
            Assert.AreEqual(0, delayHandler    .Calls);
            Assert.AreEqual(0, retryHandler    .Calls);
            Assert.AreEqual(0, failedHandler   .Calls);
            Assert.AreEqual(0, exhaustedHandler.Calls);
        }

        #endregion

        #region Invoke_Failure

        private void Invoke_Failure(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBrackets #>, CancellationToken, Type> assertInvoke, bool addEventHandlers)
        {
            // Create an "unsuccessful" user-defined action
            <#= inputActionKind #>Proxy<#= inputActionTypeArguments #> action = new <#= inputActionKind #>Proxy<#= inputActionTypeArguments #>(<#= GetThrowDelegate<OutOfMemoryException>(parameterCount, async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<Exception, bool>          exceptionHandler  = new FuncProxy<Exception, bool>(ExceptionPolicy.Fail<OutOfMemoryException>().Invoke);
            FuncProxy<int, Exception, TimeSpan> delayHandler      = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke,
                Retries.Infinite,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action          .Invoking += Expect.Arguments<#= typeArguments #>(Arguments.Validate);
<#
        }
#>
            exceptionHandler.Invoking += Expect.Exception(typeof(OutOfMemoryException));
            delayHandler    .Invoking += Expect.Nothing<int, Exception>();
            retryHandler    .Invoking += Expect.Nothing<int, Exception>();
            failedHandler   .Invoking += Expect.Exception(typeof(OutOfMemoryException));
            exhaustedHandler.Invoking += Expect.Nothing<Exception>();

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= argumentValues #>, tokenSource.Token, typeof(OutOfMemoryException));

            // Validate the number of calls
            Assert.AreEqual(1, action          .Calls);
            Assert.AreEqual(1, exceptionHandler.Calls);
            Assert.AreEqual(0, delayHandler    .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(0, retryHandler    .Calls);
                Assert.AreEqual(1, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_EventualSuccess

        private void Invoke_EventualSuccess(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBrackets #>, CancellationToken> assertInvoke, bool addEventHandlers)
        {
            // Create a "successful" user-defined action that completes after 1 IOException
            Action flakyAction = FlakyAction.Create<IOException>(1);
            <#= inputActionKind #>Proxy<#= inputActionTypeArguments #> action = new <#= inputActionKind #>Proxy<#= inputActionTypeArguments #>(<#= GetActionInvokeDelegate(parameterCount, "flakyAction", async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<Exception, bool>          exceptionHandler  = new FuncProxy<Exception, bool>(ExceptionPolicy.Retry<IOException>().Invoke);
            FuncProxy<int, Exception, TimeSpan> delayHandler      = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke,
                Retries.Infinite,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action          .Invoking += Expect.ArgumentsAfterDelay<#= typeArguments #>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            action          .Invoking += Expect.AfterDelay<#= typeArguments #>(Constants.MinDelay);
<#
        }
#>
            exceptionHandler.Invoking += Expect.Exception(typeof(IOException));
            delayHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            retryHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            failedHandler   .Invoking += Expect.Nothing<Exception>();
            exhaustedHandler.Invoking += Expect.Nothing<Exception>();

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= argumentValues #>, tokenSource.Token);

            // Validate the number of calls
            Assert.AreEqual(2, action          .Calls);
            Assert.AreEqual(1, exceptionHandler.Calls);
            Assert.AreEqual(1, delayHandler    .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(1, retryHandler    .Calls);
                Assert.AreEqual(0, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_EventualFailure

        private void Invoke_EventualFailure(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBrackets #>, CancellationToken, Type> assertInvoke, bool addEventHandlers)
        {
            // Create an "unsuccessful" user-defined action that fails after 2 transient exceptions
            Action flakyAction = FlakyAction.Create<IOException, OutOfMemoryException>(2);
            <#= inputActionKind #>Proxy<#= inputActionTypeArguments #> action = new <#= inputActionKind #>Proxy<#= inputActionTypeArguments #>(<#= GetActionInvokeDelegate(parameterCount, "flakyAction", async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<Exception, bool>          exceptionHandler  = new FuncProxy<Exception, bool>(ExceptionPolicy.Retry<IOException>().Invoke);
            FuncProxy<int, Exception, TimeSpan> delayHandler      = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke,
                Retries.Infinite,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action          .Invoking += Expect.ArgumentsAfterDelay<#= typeArguments #>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            action          .Invoking += Expect.AfterDelay<#= typeArguments #>(Constants.MinDelay);
<#
        }
#>
            exceptionHandler.Invoking += Expect.Exceptions(typeof(IOException), typeof(OutOfMemoryException), 2);
            delayHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            retryHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            failedHandler   .Invoking += Expect.Exception(typeof(OutOfMemoryException));
            exhaustedHandler.Invoking += Expect.Nothing<Exception>();

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= argumentValues #>, tokenSource.Token, typeof(OutOfMemoryException));

            // Validate the number of calls
            Assert.AreEqual(3, action          .Calls);
            Assert.AreEqual(3, exceptionHandler.Calls);
            Assert.AreEqual(2, delayHandler    .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(2, retryHandler    .Calls);
                Assert.AreEqual(1, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_RetriesExhausted

        private void Invoke_RetriesExhausted(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBrackets #>, CancellationToken, Type> assertInvoke, bool addEventHandlers)
        {
            // Create an "unsuccessful" user-defined action that exhausts the configured number of retries
            <#= inputActionKind #>Proxy<#= inputActionTypeArguments #> action = new <#= inputActionKind #>Proxy<#= inputActionTypeArguments #>(<#= GetThrowDelegate<IOException>(parameterCount, async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<Exception, bool>          exceptionHandler  = new FuncProxy<Exception, bool>(ExceptionPolicy.Retry<IOException>().Invoke);
            FuncProxy<int, Exception, TimeSpan> delayHandler      = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke,
                2,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action          .Invoking += Expect.ArgumentsAfterDelay<#= typeArguments #>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            action          .Invoking += Expect.AfterDelay<#= typeArguments #>(Constants.MinDelay);
<#
        }
#>
            exceptionHandler.Invoking += Expect.Exception(typeof(IOException));
            delayHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            retryHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            failedHandler   .Invoking += Expect.Nothing<Exception>();
            exhaustedHandler.Invoking += Expect.Exception(typeof(IOException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= argumentValues #>, tokenSource.Token, typeof(IOException));

            // Validate the number of calls
            Assert.AreEqual(3, action          .Calls);
            Assert.AreEqual(3, exceptionHandler.Calls);
            Assert.AreEqual(2, delayHandler    .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(2, retryHandler    .Calls);
                Assert.AreEqual(0, failedHandler   .Calls);
                Assert.AreEqual(1, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_Canceled_Action

        private void Invoke_Canceled_Action(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBrackets #>, CancellationToken> invoke, bool addEventHandlers<#= async ? ", bool useSynchronousAction" : string.Empty #>)
        {
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            // Create a user-defined action that will throw an exception depending on whether its canceled
<#
        if (async)
        {
#>
            // Note: We need to separately check the use of asynchronous and synchronous methods when checking cancellation
            <#= inputActionKind #>Proxy<#= tokenInputActionTypeArguments #> action = useSynchronousAction
                ? new <#= inputActionKind #>Proxy<#= tokenInputActionTypeArguments #>(
                    (<#= arguments #><#= optionalComma #>token) =>
                    {
                        token.ThrowIfCancellationRequested();
                        throw new IOException();
                    })
                : new <#= inputActionKind #>Proxy<#= tokenInputActionTypeArguments #>(
                    async (<#= arguments #><#= optionalComma #>token) =>
                    {
                        token.ThrowIfCancellationRequested();
                        await Task.FromException(new IOException());
                    });
<#
        }
        else
        {
#>
            <#= inputActionKind #>Proxy<#= tokenInputActionTypeArguments #> action = new <#= inputActionKind #>Proxy<#= tokenInputActionTypeArguments #>(
                (<#= arguments #><#= optionalComma #>token) =>
                {
                    token.ThrowIfCancellationRequested();
                    throw new IOException();
                });
<#
        }
#>

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<Exception, bool>          exceptionHandler  = new FuncProxy<Exception, bool>(ExceptionPolicy.Transient.Invoke);
            FuncProxy<int, Exception, TimeSpan> delayHandler      = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke,
                Retries.Infinite,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
            action          .Invoking += Expect.ArgumentsAfterDelay<<#= typeArgumentsNoBrackets #><#= optionalComma #>CancellationToken>(Arguments.Validate, Constants.MinDelay);
            exceptionHandler.Invoking += Expect.Exception(typeof(IOException));
            delayHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            retryHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            failedHandler   .Invoking += Expect.Nothing<Exception>();
            exhaustedHandler.Invoking += Expect.Nothing<Exception>();

            // Cancel the action on its 2nd attempt
            action          .Invoking += (<#= arguments #><#= optionalComma #>t, c) =>
            {
                if (c.Calls == 2)
                    tokenSource.Cancel();
            };

            // Invoke, retry, and cancel
            Assert.That.ThrowsException<OperationCanceledException>(() => invoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= argumentValues #>, tokenSource.Token), allowedDerivedTypes: true);

            // Validate the number of calls
            Assert.AreEqual(2, action          .Calls);
            Assert.AreEqual(1, exceptionHandler.Calls);
            Assert.AreEqual(1, delayHandler    .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(1, retryHandler    .Calls);
                Assert.AreEqual(0, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_Canceled_Delay

        private void Invoke_Canceled_Delay(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBrackets #>, CancellationToken> invoke, bool addEventHandlers)
        {
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            // Create an "unsuccessful" user-defined action that continues to fail with transient exceptions until it's canceled
            <#= inputActionKind #>Proxy<#= inputActionTypeArguments #> action = new <#= inputActionKind #>Proxy<#= inputActionTypeArguments #>(<#= GetThrowDelegate<IOException>(parameterCount, async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<Exception, bool>          exceptionHandler  = new FuncProxy<Exception, bool>(ExceptionPolicy.Transient.Invoke);
            FuncProxy<int, Exception, TimeSpan> delayHandler      = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke,
                Retries.Infinite,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action          .Invoking += Expect.ArgumentsAfterDelay<#= typeArguments #>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            action          .Invoking += Expect.AfterDelay<#= typeArguments #>(Constants.MinDelay);
<#
        }
#>
            exceptionHandler.Invoking += Expect.Exception(typeof(IOException));
            delayHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            retryHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            failedHandler   .Invoking += Expect.Nothing<Exception>();
            exhaustedHandler.Invoking += Expect.Nothing<Exception>();

            // Cancel the delay on its 2nd invocation
            delayHandler    .Invoking += (i, e, c) =>
            {
                if (c.Calls == 2)
                    tokenSource.Cancel();
            };

            // Invoke, retry, and cancel
            Assert.That.ThrowsException<OperationCanceledException>(() => invoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= argumentValues #>, tokenSource.Token), allowedDerivedTypes: true);

            // Validate the number of calls
            Assert.AreEqual(2, action          .Calls);
            Assert.AreEqual(2, exceptionHandler.Calls);
            Assert.AreEqual(2, delayHandler    .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(1, retryHandler    .Calls);
                Assert.AreEqual(0, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion
    }
}
<#
        string fileName = parameterCount == 0 ? $"Reliable{optionalAsync}Action.Test.cs" : $"Reliable{optionalAsync}Action.T{parameterCount}.Test.cs";
        SaveOutput(fileName);
    }
#>
<#= GetTemplateFileName() #> ran successfully
