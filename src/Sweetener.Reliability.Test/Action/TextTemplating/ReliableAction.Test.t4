<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".tt.out" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="$(MSBuildProjectDirectory)\TextTemplating\Include.t4" #><#
    // Assume a boolean variable called "async" has been previously defined!
    string optionalAsync = async ? "Async" : string.Empty;

    for (int parameterCount = 0; parameterCount <= MaxDelegateParameters; parameterCount++)
    {
        string arguments              = GetArguments    (parameterCount);
        string parameters             = GetParameters   (typeArgs, parameterCount);
        string typeArguments          = GetTypeArguments(parameterCount);
        string typeArgumentsNoBracket = GetTypeArguments(parameterCount, includeBrackets: false);
        string testArguments          = GetTestArguments(parameterCount);
        string typeParameters         = parameterCount == 0 ? string.Empty : "<" + GetTypeParameters(parameterCount) + ">";
        string optionalComma          = parameterCount > 0 ? ", " : string.Empty;
#>
// Generated from <#= GetTemplateFileName() #>
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Sweetener.Reliability.Test
{
    [TestClass]
    public sealed class Reliable<#= optionalAsync #>Action<#= parameterCount > 0 ? parameterCount.ToString() : string.Empty #>Test : ReliableDelegateTest
    {
        private static readonly Func<Reliable<#= optionalAsync #>Action<#= typeArguments #>, <#= optionalAsync #>Action<#= typeArguments #>> s_getAction = DynamicGetter.ForField<Reliable<#= optionalAsync #>Action<#= typeArguments #>, <#= optionalAsync #>Action<#= typeArguments #>>("_action");

        [TestMethod]
        public void Ctor_DelayPolicy()
            => Ctor_DelayPolicy((a, m, d, e) => new Reliable<#= optionalAsync #>Action<#= typeArguments #>(a, m, d, e));

        [TestMethod]
        public void Ctor_ComplexDelayPolicy()
            => Ctor_ComplexDelayPolicy((a, m, d, e) => new Reliable<#= optionalAsync #>Action<#= typeArguments #>(a, m, d, e));

<#
        if (!async)
        {
#>
        [TestMethod]
        public void Create_DelayPolicy()
            => Ctor_DelayPolicy((a, m, d, e) => Reliable<#= optionalAsync #>Action.Create(a, m, d, e));

        [TestMethod]
        public void Create_ComplexDelayPolicy()
            => Ctor_ComplexDelayPolicy((a, m, d, e) => Reliable<#= optionalAsync #>Action.Create(a, m, d, e));

        [TestMethod]
        public void Invoke_NoCancellationToken()
            => Invoke((r<#= optionalComma #><#= arguments #>) => r.Invoke(<#= arguments #>));

        [TestMethod]
        public void Invoke_CancellationToken()
        {
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Invoke((r<#= optionalComma #><#= arguments #>) => r.Invoke(<#= arguments #><#= optionalComma #>tokenSource.Token));

            // Ensure CancellationToken prevents additional retry
            Invoke_Canceled((r<#= optionalComma #><#= arguments #>, token) => r.Invoke(<#= arguments #><#= optionalComma #>token), addEventHandlers: false);
            Invoke_Canceled((r<#= optionalComma #><#= arguments #>, token) => r.Invoke(<#= arguments #><#= optionalComma #>token), addEventHandlers: true );
        }

<#
        }
#>
        [TestMethod]
        public void InvokeAsync_NoCancellationToken()
            => InvokeAsync(async (r<#= optionalComma #><#= arguments #>) => await r.InvokeAsync(<#= arguments #>).ConfigureAwait(false));

        [TestMethod]
        public void InvokeAsync_CancellationToken()
        {
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                InvokeAsync(async (r<#= optionalComma #><#= arguments #>) => await r.InvokeAsync(<#= arguments #><#= optionalComma #>tokenSource.Token).ConfigureAwait(false));

            // Ensure CancellationToken prevents additional retry
            Invoke_Canceled(async (r<#= optionalComma #><#= arguments #>, token) => await r.InvokeAsync(<#= arguments #><#= optionalComma #>token), addEventHandlers: false);
            Invoke_Canceled(async (r<#= optionalComma #><#= arguments #>, token) => await r.InvokeAsync(<#= arguments #><#= optionalComma #>token), addEventHandlers: true );
        }

<#
        if (!async)
        {
#>
        [TestMethod]
        public void TryInvoke_NoCancellationToken()
            => TryInvoke((r<#= optionalComma #><#= arguments #>) => r.TryInvoke(<#= arguments #>));

        [TestMethod]
        public void TryInvoke_CancellationToken()
        {
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                TryInvoke((r<#= optionalComma #><#= arguments #>) => r.TryInvoke(<#= arguments #><#= optionalComma #>tokenSource.Token));

            // Ensure CancellationToken prevents additional retry
            Invoke_Canceled((r<#= optionalComma #><#= arguments #>, token) => r.TryInvoke(<#= arguments #><#= optionalComma #>token), addEventHandlers: false);
            Invoke_Canceled((r<#= optionalComma #><#= arguments #>, token) => r.TryInvoke(<#= arguments #><#= optionalComma #>token), addEventHandlers: true );
        }

<#
        }
#>
        #region Ctor

        private void Ctor_DelayPolicy(Func<<#= optionalAsync #>Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, Reliable<#= optionalAsync #>Action<#= typeArguments #>> factory)
        {
            <#= optionalAsync #>Action<#= typeArguments #> action = (<#= arguments #>) => Operation.Null<#= optionalAsync #>();
            ExceptionPolicy          exceptionPolicy = ExceptionPolicies.Fatal;
            FuncProxy<int, TimeSpan> delayPolicy     = new FuncProxy<int, TimeSpan>(i => Constants.Delay);

            Assert.ThrowsException<ArgumentNullException      >(() => factory(null  , Retries.Infinite, exceptionPolicy, delayPolicy.Invoke));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => factory(action, -2              , exceptionPolicy, delayPolicy.Invoke));
            Assert.ThrowsException<ArgumentNullException      >(() => factory(action, Retries.Infinite, null           , delayPolicy.Invoke));
            Assert.ThrowsException<ArgumentNullException      >(() => factory(action, Retries.Infinite, exceptionPolicy, null              ));

            // Create a Reliable<#= optionalAsync #>Action and validate
            Reliable<#= optionalAsync #>Action<#= typeArguments #> actual = factory(action, 37, exceptionPolicy, delayPolicy.Invoke);

            // DelayPolicies are wrapped in ComplexDelayPolicies, so we can only validate the correct assignment by invoking the policy
            Ctor(actual, action, 37, exceptionPolicy, actualPolicy =>
            {
                delayPolicy.Invoking += (i, c) => Assert.AreEqual(i, 42);
                Assert.AreEqual(Constants.Delay, actualPolicy(42, new ArgumentOutOfRangeException()));
                Assert.AreEqual(1, delayPolicy.Calls);
            });
        }

        private void Ctor_ComplexDelayPolicy(Func<<#= optionalAsync #>Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, Reliable<#= optionalAsync #>Action<#= typeArguments #>> factory)
        {
            <#= optionalAsync #>Action<#= typeArguments #> action = (<#= arguments #>) => Operation.Null<#= optionalAsync #>();
            ExceptionPolicy    exceptionPolicy    = ExceptionPolicies.Fatal;
            ComplexDelayPolicy complexDelayPolicy = (i, e) => TimeSpan.FromHours(1);

            Assert.ThrowsException<ArgumentNullException      >(() => factory(null  , Retries.Infinite, exceptionPolicy, complexDelayPolicy));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => factory(action, -2              , exceptionPolicy, complexDelayPolicy));
            Assert.ThrowsException<ArgumentNullException      >(() => factory(action, Retries.Infinite, null           , complexDelayPolicy));
            Assert.ThrowsException<ArgumentNullException      >(() => factory(action, Retries.Infinite, exceptionPolicy, (ComplexDelayPolicy)null));

            // Create a Reliable<#= optionalAsync #>Action and validate
            Reliable<#= optionalAsync #>Action<#= typeArguments #> actual = factory(action, 37, exceptionPolicy, complexDelayPolicy);
            Ctor(actual, action, 37, exceptionPolicy, complexDelayPolicy);
        }

        private void Ctor(Reliable<#= optionalAsync #>Action<#= typeArguments #> reliableAction, <#= optionalAsync #>Action<#= typeArguments #> expectedAction, int expectedMaxRetries, ExceptionPolicy expectedExceptionPolicy, ComplexDelayPolicy expectedDelayPolicy)
            => Ctor(reliableAction, expectedAction, expectedMaxRetries, expectedExceptionPolicy, actual => Assert.AreSame(expectedDelayPolicy, actual));

        private void Ctor(Reliable<#= optionalAsync #>Action<#= typeArguments #> reliableAction, <#= optionalAsync #>Action<#= typeArguments #> expectedAction, int expectedMaxRetries, ExceptionPolicy expectedExceptionPolicy, Action<ComplexDelayPolicy> validateDelayPolicy)
        {
            Assert.AreSame (expectedAction         , s_getAction(reliableAction)         );
            Assert.AreEqual(expectedMaxRetries     , reliableAction.MaxRetries           );
            Assert.AreSame (expectedExceptionPolicy, s_getExceptionPolicy(reliableAction));

            validateDelayPolicy(s_getDelayPolicy(reliableAction));
        }

        #endregion

<#
        if (!async)
        {
#>
        #region Invoke

        private void Invoke(Action<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> invoke)
        {
            // Callers may optionally include event handlers
            foreach (bool addEventHandlers in new bool[] { false, true })
            {
                Invoke_Success        (invoke, addEventHandlers);
                Invoke_EventualSuccess(invoke, addEventHandlers);

                Invoke_Failure         ((r<#= optionalComma #><#= arguments #>, e) => Assert.That.ThrowsException(() => invoke(r<#= optionalComma #><#= arguments #>), e), addEventHandlers);
                Invoke_EventualFailure ((r<#= optionalComma #><#= arguments #>, e) => Assert.That.ThrowsException(() => invoke(r<#= optionalComma #><#= arguments #>), e), addEventHandlers);
                Invoke_RetriesExhausted((r<#= optionalComma #><#= arguments #>, e) => Assert.That.ThrowsException(() => invoke(r<#= optionalComma #><#= arguments #>), e), addEventHandlers);
            }
        }

        #endregion

<#
        }
#>
        #region InvokeAsync

        private void InvokeAsync(AsyncAction<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> invokeAsync)
        {
            // Callers may optionally include event handlers
            foreach (bool addEventHandlers in new bool[] { false, true })
            {
                Invoke_Success        ((r<#= optionalComma #><#= arguments #>) => invokeAsync(r<#= optionalComma #><#= arguments #>).Wait(), addEventHandlers);
                Invoke_EventualSuccess((r<#= optionalComma #><#= arguments #>) => invokeAsync(r<#= optionalComma #><#= arguments #>).Wait(), addEventHandlers);

                Invoke_Failure         ((r<#= optionalComma #><#= arguments #>, e) => Assert.That.ThrowsException(async () => await invokeAsync(r<#= optionalComma #><#= arguments #>).ConfigureAwait(false), e), addEventHandlers);
                Invoke_EventualFailure ((r<#= optionalComma #><#= arguments #>, e) => Assert.That.ThrowsException(async () => await invokeAsync(r<#= optionalComma #><#= arguments #>).ConfigureAwait(false), e), addEventHandlers);
                Invoke_RetriesExhausted((r<#= optionalComma #><#= arguments #>, e) => Assert.That.ThrowsException(async () => await invokeAsync(r<#= optionalComma #><#= arguments #>).ConfigureAwait(false), e), addEventHandlers);
            }
        }

        #endregion

<#
        if (!async)
        {
#>
        #region TryInvoke

        private void TryInvoke(Func<ReliableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, bool> tryInvoke)
        {
            // Callers may optionally include event handlers
            foreach (bool addEventHandlers in new bool[] { false, true })
            {
                Invoke_Success         ((r<#= optionalComma #><#= arguments #>   ) => Assert.IsTrue (tryInvoke(r<#= optionalComma #><#= arguments #>)), addEventHandlers);
                Invoke_EventualSuccess ((r<#= optionalComma #><#= arguments #>   ) => Assert.IsTrue (tryInvoke(r<#= optionalComma #><#= arguments #>)), addEventHandlers);
                Invoke_Failure         ((r<#= optionalComma #><#= arguments #>, e) => Assert.IsFalse(tryInvoke(r<#= optionalComma #><#= arguments #>)), addEventHandlers);
                Invoke_EventualFailure ((r<#= optionalComma #><#= arguments #>, e) => Assert.IsFalse(tryInvoke(r<#= optionalComma #><#= arguments #>)), addEventHandlers);
                Invoke_RetriesExhausted((r<#= optionalComma #><#= arguments #>, e) => Assert.IsFalse(tryInvoke(r<#= optionalComma #><#= arguments #>)), addEventHandlers);
            }
        }

        #endregion

<#
        }
#>
        #region Invoke_Success

        private void Invoke_Success(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> assertInvoke, bool addEventHandlers)
        {
            // Create a "successful" user-defined action
            <#= optionalAsync #>ActionProxy<#= typeArguments #> action = new <#= optionalAsync #>ActionProxy<#= typeArguments #>(<#= GetNoOpInvoke(parameterCount, async) #>);

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool>          exceptionPolicy  = new FuncProxy<Exception, bool>();
            FuncProxy<int, Exception, TimeSpan> delayPolicy      = new FuncProxy<int, Exception, TimeSpan>();

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke<#= optionalAsync #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action          .Invoking += Expect.Arguments<#= typeArguments #>(Arguments.Validate);
<#
        }
#>
            exceptionPolicy .Invoking += Expect.Nothing<Exception>();
            delayPolicy     .Invoking += Expect.Nothing<int, Exception>();
            retryHandler    .Invoking += Expect.Nothing<int, Exception>();
            failedHandler   .Invoking += Expect.Nothing<Exception>();
            exhaustedHandler.Invoking += Expect.Nothing<Exception>();

            // Invoke
            assertInvoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= testArguments #>);

            // Validate the number of calls
            Assert.AreEqual(1, action          .Calls);
            Assert.AreEqual(0, exceptionPolicy .Calls);
            Assert.AreEqual(0, delayPolicy     .Calls);
            Assert.AreEqual(0, retryHandler    .Calls);
            Assert.AreEqual(0, failedHandler   .Calls);
            Assert.AreEqual(0, exhaustedHandler.Calls);
        }

        #endregion

        #region Invoke_Failure

        private void Invoke_Failure(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, Type> assertInvoke, bool addEventHandlers)
        {
            // Create an "unsuccessful" user-defined action
            <#= optionalAsync #>ActionProxy<#= typeArguments #> action = new <#= optionalAsync #>ActionProxy<#= typeArguments #>(<#= GetThrowException<InvalidOperationException>(parameterCount, async) #>);

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool>          exceptionPolicy  = new FuncProxy<Exception, bool>(ExceptionPolicies.Fail<InvalidOperationException>().Invoke);
            FuncProxy<int, Exception, TimeSpan> delayPolicy      = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke<#= optionalAsync #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action          .Invoking += Expect.Arguments<#= typeArguments #>(Arguments.Validate);
<#
        }
#>
            exceptionPolicy .Invoking += Expect.Exception(typeof(InvalidOperationException));
            delayPolicy     .Invoking += Expect.Nothing<int, Exception>();
            retryHandler    .Invoking += Expect.Nothing<int, Exception>();
            failedHandler   .Invoking += Expect.Exception(typeof(InvalidOperationException));
            exhaustedHandler.Invoking += Expect.Nothing<Exception>();

            // Invoke
            assertInvoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= testArguments #>, typeof(InvalidOperationException));

            // Validate the number of calls
            Assert.AreEqual(1, action         .Calls);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(0, retryHandler    .Calls);
                Assert.AreEqual(1, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_EventualSuccess

        private void Invoke_EventualSuccess(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>> assertInvoke, bool addEventHandlers)
        {
            // Create a "successful" user-defined action that completes after 1 IOException
            Action flakyAction = FlakyAction.Create<IOException>(1);
            <#= optionalAsync #>ActionProxy<#= typeArguments #> action = new <#= optionalAsync #>ActionProxy<#= typeArguments #>(<#= GetDelegateInvoke(parameterCount, "flakyAction", async) #>);

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool>          exceptionPolicy  = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            FuncProxy<int, Exception, TimeSpan> delayPolicy      = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke<#= optionalAsync #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action          .Invoking += Expect.ArgumentsAfterDelay<#= typeArguments #>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            action          .Invoking += Expect.AfterDelay<#= typeArguments #>(Constants.MinDelay);
<#
        }
#>
            exceptionPolicy .Invoking += Expect.Exception(typeof(IOException));
            delayPolicy     .Invoking += Expect.ExceptionAsc(typeof(IOException));
            retryHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            failedHandler   .Invoking += Expect.Nothing<Exception>();
            exhaustedHandler.Invoking += Expect.Nothing<Exception>();

            // Invoke
            assertInvoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= testArguments #>);

            // Validate the number of calls
            Assert.AreEqual(2, action         .Calls);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(1, delayPolicy    .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(1, retryHandler    .Calls);
                Assert.AreEqual(0, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_EventualFailure

        private void Invoke_EventualFailure(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, Type> assertInvoke, bool addEventHandlers)
        {
            // Create an "unsuccessful" user-defined action that fails after 2 transient exceptions
            Action flakyAction = FlakyAction.Create<IOException, InvalidOperationException>(2);
            <#= optionalAsync #>ActionProxy<#= typeArguments #> action = new <#= optionalAsync #>ActionProxy<#= typeArguments #>(<#= GetDelegateInvoke(parameterCount, "flakyAction", async) #>);

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool>          exceptionPolicy  = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            FuncProxy<int, Exception, TimeSpan> delayPolicy      = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke<#= optionalAsync #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action          .Invoking += Expect.ArgumentsAfterDelay<#= typeArguments #>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            action          .Invoking += Expect.AfterDelay<#= typeArguments #>(Constants.MinDelay);
<#
        }
#>
            exceptionPolicy .Invoking += Expect.Exceptions(typeof(IOException), typeof(InvalidOperationException), 2);
            delayPolicy     .Invoking += Expect.ExceptionAsc(typeof(IOException));
            retryHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            failedHandler   .Invoking += Expect.Exception(typeof(InvalidOperationException));
            exhaustedHandler.Invoking += Expect.Nothing<Exception>();

            // Invoke
            assertInvoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= testArguments #>, typeof(InvalidOperationException));

            // Validate the number of calls
            Assert.AreEqual(3, action         .Calls);
            Assert.AreEqual(3, exceptionPolicy.Calls);
            Assert.AreEqual(2, delayPolicy    .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(2, retryHandler    .Calls);
                Assert.AreEqual(1, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_RetriesExhausted

        private void Invoke_RetriesExhausted(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, Type> assertInvoke, bool addEventHandlers)
        {
            // Create an "unsuccessful" user-defined action that exhausts the configured number of retries
            <#= optionalAsync #>ActionProxy<#= typeArguments #> action = new <#= optionalAsync #>ActionProxy<#= typeArguments #>(<#= GetThrowException<IOException>(parameterCount, async) #>);

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool>          exceptionPolicy  = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            FuncProxy<int, Exception, TimeSpan> delayPolicy      = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke<#= optionalAsync #>,
                2,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action          .Invoking += Expect.ArgumentsAfterDelay<#= typeArguments #>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            action          .Invoking += Expect.AfterDelay<#= typeArguments #>(Constants.MinDelay);
<#
        }
#>
            exceptionPolicy .Invoking += Expect.Exception(typeof(IOException));
            delayPolicy     .Invoking += Expect.ExceptionAsc(typeof(IOException));
            retryHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            failedHandler   .Invoking += Expect.Nothing<Exception>();
            exhaustedHandler.Invoking += Expect.Exception(typeof(IOException));

            // Invoke
            assertInvoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= testArguments #>, typeof(IOException));

            // Validate the number of calls
            Assert.AreEqual(3, action         .Calls);
            Assert.AreEqual(3, exceptionPolicy.Calls);
            Assert.AreEqual(2, delayPolicy    .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(2, retryHandler    .Calls);
                Assert.AreEqual(0, failedHandler   .Calls);
                Assert.AreEqual(1, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_Canceled

        private void Invoke_Canceled(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke, bool addEventHandlers)
            => Invoke_Canceled_Delay((r<#= optionalComma #><#= arguments #>, token) => Assert.That.ThrowsException<OperationCanceledException>(() => invoke(r<#= optionalComma #><#= arguments #>, token)), addEventHandlers);

        // The Async method will expose a "TaskCanceledException" directly
        private void Invoke_Canceled(AsyncAction<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invokeAsync, bool addEventHandlers)
            => Invoke_Canceled_Delay((r<#= optionalComma #><#= arguments #>, token) => Assert.That.ThrowsException<TaskCanceledException>(async () => await invokeAsync(r<#= optionalComma #><#= arguments #>, token).ConfigureAwait(false)), addEventHandlers);

        private void Invoke_Canceled_Delay(Action<Reliable<#= optionalAsync #>Action<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> assertInvoke, bool addEventHandlers)
        {
            using ManualResetEvent        cancellationTrigger = new ManualResetEvent(false);
            using CancellationTokenSource tokenSource         = new CancellationTokenSource();

            // Create an "unsuccessful" user-defined action that continues to fail with transient exceptions until it's canceled
            <#= optionalAsync #>ActionProxy<#= typeArguments #> action = new <#= optionalAsync #>ActionProxy<#= typeArguments #>(<#= GetThrowException<IOException>(parameterCount, async) #>);

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool>          exceptionPolicy  = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            FuncProxy<int, Exception, TimeSpan> delayPolicy      = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);

            ActionProxy<int, Exception>         retryHandler     = new ActionProxy<int, Exception>();
            ActionProxy<Exception>              failedHandler    = new ActionProxy<Exception>();
            ActionProxy<Exception>              exhaustedHandler = new ActionProxy<Exception>();

            // Create Reliable<#= optionalAsync #>Action
            Reliable<#= optionalAsync #>Action<#= typeArguments #> reliable<#= optionalAsync #>Action = new Reliable<#= optionalAsync #>Action<#= typeArguments #>(
                action.Invoke<#= optionalAsync #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy    .Invoke);

            if (addEventHandlers)
            {
                reliable<#= optionalAsync #>Action.Retrying         += retryHandler    .Invoke;
                reliable<#= optionalAsync #>Action.Failed           += failedHandler   .Invoke;
                reliable<#= optionalAsync #>Action.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action          .Invoking += Expect.ArgumentsAfterDelay<#= typeArguments #>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            action          .Invoking += Expect.AfterDelay<#= typeArguments #>(Constants.MinDelay);
<#
        }
#>
            exceptionPolicy .Invoking += Expect.Exception(typeof(IOException));
            delayPolicy     .Invoking += Expect.ExceptionAsc(typeof(IOException));
            retryHandler    .Invoking += Expect.ExceptionAsc(typeof(IOException));
            failedHandler   .Invoking += Expect.Nothing<Exception>();
            exhaustedHandler.Invoking += Expect.Nothing<Exception>();

            // Trigger the event upon retry
            action          .Invoking += (<#= arguments #><#= optionalComma #>c) =>
            {
                if (c.Calls > 1)
                    cancellationTrigger.Set();
            };

            // Create a task whose job is to cancel the invocation after at least 1 retry
            Task cancellationTask = Task.Factory.StartNew((state) =>
            {
                (ManualResetEvent e, CancellationTokenSource s) = ((ManualResetEvent, CancellationTokenSource))state;
                e.WaitOne();
                s.Cancel();

            }, (cancellationTrigger, tokenSource));

            // Begin the invocation
            assertInvoke(reliable<#= optionalAsync #>Action<#= optionalComma #><#= testArguments #>, tokenSource.Token);

            // Validate the number of calls
            int calls = action.Calls;
            Assert.IsTrue(calls > 1);

            Assert.AreEqual(calls, action         .Calls);
            Assert.AreEqual(calls, exceptionPolicy.Calls);
            Assert.AreEqual(calls, delayPolicy    .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(calls - 1, retryHandler    .Calls);
                Assert.AreEqual(0        , failedHandler   .Calls);
                Assert.AreEqual(0        , exhaustedHandler.Calls);
            }
        }

        #endregion
    }
}
<#
        string fileName = parameterCount == 0 ? $"Reliable{optionalAsync}Action.Test.cs" : $"Reliable{optionalAsync}Action.T{parameterCount}.Test.cs";
        SaveOutput(fileName);
    }
#>
<#= GetTemplateFileName() #> ran successfully
