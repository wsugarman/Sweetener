<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="$(MSBuildProjectDirectory)\TextTemplating\Include.t4" #>// Generated from <#= GetTemplateFileName() #>
using System;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Sweetener.Reliability.Test
{
    partial class ReliablyTest
    {
<#
    string optionalAsyncPrefix = async ? "Async"                    : string.Empty;
    string basicActionType     = async ? "Func<Task>"               : "Action";
    string statefulActionType  = async ? "Func<object, Task>"       : "Action<object>";
    string basicTestAction     = async ? "() => Task.CompletedTask" : "Operation.Null";
    string statefulTestAction  = async ? "s => Task.CompletedTask"  : "s => Operation.Null()";

    if (!async)
    {
#>
        #region Invoke

<#
        foreach (bool stateful in new bool[2] { false, true })
        {
            string inputActionType        = stateful ? statefulActionType : basicActionType;
            string testAction             = stateful ? statefulTestAction : basicTestAction;
            string optionalStateObj       = stateful ? ", new object()"   : string.Empty;
            string optionalStatefulSuffix = stateful ? "_Stateful"        : string.Empty;

            foreach (bool interruptable in new bool[2] { false, true })
            {
                string optionalTokenObj    = interruptable ? ", CancellationToken.None" : string.Empty;
                string optionalTokenArg    = interruptable ? ", t"                      : string.Empty;
                string optionalTokenSuffix = interruptable ? "_Interruptable"           : string.Empty;

                foreach (bool useComplexDelayHandler in new bool[2] { false, true })
                {
                    string handlerType          = useComplexDelayHandler ? "ComplexDelayHandler"     : "DelayHandler";
                    string delayInputTypeParam  = useComplexDelayHandler ? "int, Exception"          : "int";
                    string delayInputArgs       = useComplexDelayHandler ? "(i, e)"                  : "i";
                    string noDelay              = useComplexDelayHandler ? "(i, e) => TimeSpan.Zero" : "DelayPolicy.None";
                    string delayCallExpectation = useComplexDelayHandler ? "ExceptionAsc(t)"         : "Asc()";
                    string delaySuffix          = useComplexDelayHandler ? "_ComplexDelayHandler"    : "_DelayHandler";

                    string testName = "Invoke_" + optionalAsyncPrefix + "Action" + optionalStatefulSuffix + optionalTokenSuffix + delaySuffix;
#>
        [TestMethod]
        public void <#= testName #>()
        {
#nullable disable

            <#= inputActionType #> nullAction = null;
            <#= inputActionType #> testAction = <#= testAction #>;
            Assert.ThrowsException<ArgumentNullException      >(() => Reliably.Invoke(nullAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, ExceptionPolicy.Transient, <#= noDelay #>));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => Reliably.Invoke(testAction<#= optionalStateObj #><#= optionalTokenObj #>, -3, ExceptionPolicy.Transient, <#= noDelay #>));
            Assert.ThrowsException<ArgumentNullException      >(() => Reliably.Invoke(testAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, null                     , <#= noDelay #>));
            Assert.ThrowsException<ArgumentNullException      >(() => Reliably.Invoke(testAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, ExceptionPolicy.Transient, (<#= handlerType #>)null));

#nullable enable

<#
                    if (stateful)
                    {
#>
            Action<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>> invoke = (a, t, n, e, d) =>
            {
                object state = new object();
                Reliably.Invoke(obj => { Assert.AreSame(obj, state); a(); }, state<#= optionalTokenArg #>, n, e, d.Invoke);
            };
<#
                    }
                    else
                    {
#>
            Action<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>>       invoke      = (a, t, n, e, d)    => Reliably.Invoke(a<#= optionalTokenArg #>, n, e, d.Invoke);
<#
                    }
#>
            Action<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>, Type> assertError = (a, t, n, e, d, x) => Assert.That.ThrowsException(() => invoke(a, t, n, e, d), x);

            Invoke_Action_Success         (invoke     , t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t),  d     => d.Invoking += Expect.Nothing<<#= delayInputTypeParam #>>());
            Invoke_Action_Failure         (assertError, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t),  d     => d.Invoking += Expect.Nothing<<#= delayInputTypeParam #>>());
            Invoke_Action_EventualSuccess (invoke     , t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
            Invoke_Action_EventualFailure (assertError, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
            Invoke_Action_RetriesExhausted(assertError, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
<#
                    if (interruptable)
                    {
#>

            Invoke_Action_Canceled_Delegate(assertError, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
            Invoke_Action_Canceled_Delay   (assertError, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
<#
                    }
#>
        }

<#
                }
            }
        }
#>
        #endregion

<#
    }
#>
        #region InvokeAsync

<#
    foreach (bool stateful in new bool[2] { false, true })
    {
        string inputActionType        = stateful ? statefulActionType : basicActionType;
        string testAction             = stateful ? statefulTestAction : basicTestAction;
        string optionalStateObj       = stateful ? ", new object()"   : string.Empty;
        string optionalStateArg       = stateful ? ", state"          : string.Empty;
        string optionalStatefulSuffix = stateful ? "_Stateful"        : string.Empty;

        foreach (bool interruptable in new bool[2] { false, true })
        {
            string optionalTokenObj    = interruptable ? ", CancellationToken.None" : string.Empty;
            string optionalTokenArg    = interruptable ? ", t"                      : string.Empty;
            string optionalTokenSuffix = interruptable ? "_Interruptable"           : string.Empty;

            foreach (bool useComplexDelayHandler in new bool[2] { false, true })
            {
                string handlerType          = useComplexDelayHandler ? "ComplexDelayHandler"     : "DelayHandler";
                string delayInputTypeParam  = useComplexDelayHandler ? "int, Exception"          : "int";
                string delayInputArgs       = useComplexDelayHandler ? "(i, e)"                  : "i";
                string noDelay              = useComplexDelayHandler ? "(i, e) => TimeSpan.Zero" : "DelayPolicy.None";
                string delayCallExpectation = useComplexDelayHandler ? "ExceptionAsc(t)"         : "Asc()";
                string delaySuffix          = useComplexDelayHandler ? "_ComplexDelayHandler"    : "_DelayHandler";

                string testName = "InvokeAsync_" + optionalAsyncPrefix + "Action" + optionalStatefulSuffix + optionalTokenSuffix + delaySuffix;
#>
        [TestMethod]
        public async Task <#= testName #>()
        {
#nullable disable

            <#= inputActionType #> nullAction = null;
            <#= inputActionType #> testAction = <#= testAction #>;
            await Assert.ThrowsExceptionAsync<ArgumentNullException      >(() => Reliably.InvokeAsync(nullAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, ExceptionPolicy.Transient, <#= noDelay #>)).ConfigureAwait(false);
            await Assert.ThrowsExceptionAsync<ArgumentOutOfRangeException>(() => Reliably.InvokeAsync(testAction<#= optionalStateObj #><#= optionalTokenObj #>, -3, ExceptionPolicy.Transient, <#= noDelay #>)).ConfigureAwait(false);
            await Assert.ThrowsExceptionAsync<ArgumentNullException      >(() => Reliably.InvokeAsync(testAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, null                     , <#= noDelay #>)).ConfigureAwait(false);
            await Assert.ThrowsExceptionAsync<ArgumentNullException      >(() => Reliably.InvokeAsync(testAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, ExceptionPolicy.Transient, (<#= handlerType #>)null)).ConfigureAwait(false);

<#
                if (async)
                {
#>
            <#= inputActionType #> nullTaskAction = <#= stateful ? "s" : "()" #> => null;
            await Assert.ThrowsExceptionAsync<InvalidOperationException>(() => Reliably.InvokeAsync(nullTaskAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, ExceptionPolicy.Transient, <#= noDelay #>)).ConfigureAwait(false);

<#
                }
#>
#nullable enable

<#
                if (async || stateful)
                {
#>
            Func<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>, Task> invoke = (a, t, n, e, d) =>
            {
<#
                    if (stateful)
                    {
#>
                object state = new object();
<#
                    }
#>
                <#= inputActionType #> inputAction = (<#= stateful ? "obj" : string.Empty #>) =>
                {
<#
                    if (stateful)
                    {
#>
                    Assert.AreSame(obj, state);
<#
                    }
#>
                    a();
<#
                    if (async)
                    {
#>
                    return Task.CompletedTask;
<#
                    }
#>
                };

                return Reliably.InvokeAsync(inputAction<#= optionalStateArg #><#= optionalTokenArg #>, n, e, d.Invoke);
            };
<#
                }
                else
                {
#>
            Func  <Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>, Task> invoke        = (a, t, n, e, d)    => Reliably.InvokeAsync(a<#= optionalTokenArg #>, n, e, d.Invoke);
<#
                }
#>
            Action<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>>       assertSuccess = (a, t, n, e, d)    => invoke(a, t, n, e, d).Wait();
            Action<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>, Type> assertError   = (a, t, n, e, d, x) => Assert.That.ThrowsExceptionAsync(() => invoke(a, t, n, e, d), x).Wait();

            Invoke_Action_Success         (assertSuccess, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t),  d     => d.Invoking += Expect.Nothing<<#= delayInputTypeParam #>>());
            Invoke_Action_Failure         (assertError  , t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t),  d     => d.Invoking += Expect.Nothing<<#= delayInputTypeParam #>>());
            Invoke_Action_EventualSuccess (assertSuccess, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
            Invoke_Action_EventualFailure (assertError  , t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
            Invoke_Action_RetriesExhausted(assertError  , t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
<#
                if (interruptable)
                {
#>

            Invoke_Action_Canceled_Delegate(assertError, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
            Invoke_Action_Canceled_Delay   (assertError, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
<#
                }
#>
        }

<#
            }
        }
    }
#>
        #endregion

<#
    if (!async)
    {
#>
        #region TryInvoke

<#
        foreach (bool stateful in new bool[2] { false, true })
        {
            string inputActionType        = stateful ? statefulActionType : basicActionType;
            string testAction             = stateful ? statefulTestAction : basicTestAction;
            string optionalStateObj       = stateful ? ", new object()"   : string.Empty;
            string optionalStatefulSuffix = stateful ? "_Stateful"        : string.Empty;

            foreach (bool interruptable in new bool[2] { false, true })
            {
                string optionalTokenObj    = interruptable ? ", CancellationToken.None" : string.Empty;
                string optionalTokenArg    = interruptable ? ", t"                      : string.Empty;
                string optionalTokenSuffix = interruptable ? "_Interruptable"           : string.Empty;

                foreach (bool useComplexDelayHandler in new bool[2] { false, true })
                {
                    string handlerType          = useComplexDelayHandler ? "ComplexDelayHandler"     : "DelayHandler";
                    string delayInputTypeParam  = useComplexDelayHandler ? "int, Exception"          : "int";
                    string delayInputArgs       = useComplexDelayHandler ? "(i, e)"                  : "i";
                    string noDelay              = useComplexDelayHandler ? "(i, e) => TimeSpan.Zero" : "DelayPolicy.None";
                    string delayCallExpectation = useComplexDelayHandler ? "ExceptionAsc(t)"         : "Asc()";
                    string delaySuffix          = useComplexDelayHandler ? "_ComplexDelayHandler"    : "_DelayHandler";

                    string testName = "TryInvoke_" + optionalAsyncPrefix + "Action" + optionalStatefulSuffix + optionalTokenSuffix + delaySuffix;
#>
        [TestMethod]
        public void <#= testName #>()
        {
#nullable disable

            <#= inputActionType #> nullAction = null;
            <#= inputActionType #> testAction = <#= testAction #>;
            Assert.ThrowsException<ArgumentNullException      >(() => Reliably.TryInvoke(nullAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, ExceptionPolicy.Transient, <#= noDelay #>));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => Reliably.TryInvoke(testAction<#= optionalStateObj #><#= optionalTokenObj #>, -3, ExceptionPolicy.Transient, <#= noDelay #>));
            Assert.ThrowsException<ArgumentNullException      >(() => Reliably.TryInvoke(testAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, null                     , <#= noDelay #>));
            Assert.ThrowsException<ArgumentNullException      >(() => Reliably.TryInvoke(testAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, ExceptionPolicy.Transient, (<#= handlerType #>)null));

#nullable enable

<#
                    if (stateful)
                    {
#>
            Func<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>, bool> tryInvoke = (a, t, n, e, d) =>
            {
                object state = new object();
                return Reliably.TryInvoke(obj => { Assert.AreSame(obj, state); a(); }, state<#= optionalTokenArg #>, n, e, d.Invoke);
            };
<#
                    }
                    else
                    {
#>
            Func  <Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>, bool> tryInvoke = (a, t, n, e, d) => Reliably.TryInvoke(a<#= optionalTokenArg #>, n, e, d.Invoke);
<#
                    }
#>
            Action<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>>       assertSuccess = (a, t, n, e, d)    => Assert.IsTrue (tryInvoke(a, t, n, e, d));
            Action<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>, Type> assertFailure = (a, t, n, e, d, x) => Assert.IsFalse(tryInvoke(a, t, n, e, d));
<#
                    if (interruptable)
                    {
#>
            Action<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>, Type> assertError   = (a, t, n, e, d, x) => Assert.That.ThrowsException(() => tryInvoke(a, t, n, e, d), x);
<#
                    }
#>

            Invoke_Action_Success         (assertSuccess, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t),  d     => d.Invoking += Expect.Nothing<<#= delayInputTypeParam #>>());
            Invoke_Action_Failure         (assertFailure, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t),  d     => d.Invoking += Expect.Nothing<<#= delayInputTypeParam #>>());
            Invoke_Action_EventualSuccess (assertSuccess, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
            Invoke_Action_EventualFailure (assertFailure, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
            Invoke_Action_RetriesExhausted(assertFailure, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
<#
                    if (interruptable)
                    {
#>

            Invoke_Action_Canceled_Delegate(assertError, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
            Invoke_Action_Canceled_Delay   (assertError, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
<#
                    }
#>
        }

<#
                }
            }
        }
#>
        #endregion

<#
    }
#>
        #region TryInvokeAsync

<#
    foreach (bool stateful in new bool[2] { false, true })
    {
        string inputActionType        = stateful ? statefulActionType : basicActionType;
        string testAction             = stateful ? statefulTestAction : basicTestAction;
        string optionalStateObj       = stateful ? ", new object()"   : string.Empty;
        string optionalStateArg       = stateful ? ", state"          : string.Empty;
        string optionalStatefulSuffix = stateful ? "_Stateful"        : string.Empty;

        foreach (bool interruptable in new bool[2] { false, true })
        {
            string optionalTokenObj    = interruptable ? ", CancellationToken.None" : string.Empty;
            string optionalTokenArg    = interruptable ? ", t"                      : string.Empty;
            string optionalTokenSuffix = interruptable ? "_Interruptable"           : string.Empty;

            foreach (bool useComplexDelayHandler in new bool[2] { false, true })
            {
                string handlerType          = useComplexDelayHandler ? "ComplexDelayHandler"     : "DelayHandler";
                string delayInputTypeParam  = useComplexDelayHandler ? "int, Exception"          : "int";
                string delayInputArgs       = useComplexDelayHandler ? "(i, e)"                  : "i";
                string noDelay              = useComplexDelayHandler ? "(i, e) => TimeSpan.Zero" : "DelayPolicy.None";
                string delayCallExpectation = useComplexDelayHandler ? "ExceptionAsc(t)"         : "Asc()";
                string delaySuffix          = useComplexDelayHandler ? "_ComplexDelayHandler"    : "_DelayHandler";

                string testName = "TryInvokeAsync_" + optionalAsyncPrefix + "Action" + optionalStatefulSuffix + optionalTokenSuffix + delaySuffix;
#>
        [TestMethod]
        public async Task <#= testName #>()
        {
#nullable disable

            <#= inputActionType #> nullAction = null;
            <#= inputActionType #> testAction = <#= testAction #>;
            await Assert.ThrowsExceptionAsync<ArgumentNullException      >(() => Reliably.TryInvokeAsync(nullAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, ExceptionPolicy.Transient, <#= noDelay #>)).ConfigureAwait(false);
            await Assert.ThrowsExceptionAsync<ArgumentOutOfRangeException>(() => Reliably.TryInvokeAsync(testAction<#= optionalStateObj #><#= optionalTokenObj #>, -3, ExceptionPolicy.Transient, <#= noDelay #>)).ConfigureAwait(false);
            await Assert.ThrowsExceptionAsync<ArgumentNullException      >(() => Reliably.TryInvokeAsync(testAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, null                     , <#= noDelay #>)).ConfigureAwait(false);
            await Assert.ThrowsExceptionAsync<ArgumentNullException      >(() => Reliably.TryInvokeAsync(testAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, ExceptionPolicy.Transient, (<#= handlerType #>)null)).ConfigureAwait(false);

<#
                if (async)
                {
#>
            <#= inputActionType #> nullTaskAction = <#= stateful ? "s" : "()" #> => null;
            await Assert.ThrowsExceptionAsync<InvalidOperationException>(() => Reliably.TryInvokeAsync(nullTaskAction<#= optionalStateObj #><#= optionalTokenObj #>, 10, ExceptionPolicy.Transient, <#= noDelay #>)).ConfigureAwait(false);

<#
                }
#>
#nullable enable

<#
                if (async || stateful)
                {
#>
            Func<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>, Task<bool>> tryInvoke = (a, t, n, e, d) =>
            {
<#
                    if (stateful)
                    {
#>
                object state = new object();
<#
                    }
#>
                <#= inputActionType #> inputAction = (<#= stateful ? "obj" : string.Empty #>) =>
                {
<#
                    if (stateful)
                    {
#>
                    Assert.AreSame(obj, state);
<#
                    }
#>
                    a();
<#
                    if (async)
                    {
#>
                    return Task.CompletedTask;
<#
                    }
#>
                };

                return Reliably.TryInvokeAsync(inputAction<#= optionalStateArg #><#= optionalTokenArg #>, n, e, d.Invoke);
            };
<#
                }
                else
                {
#>
            Func  <Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>, Task<bool>> tryInvoke = (a, t, n, e, d)    => Reliably.TryInvokeAsync(a<#= optionalTokenArg #>, n, e, d.Invoke);
<#
                }
#>
            Action<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>>       assertSuccess = (a, t, n, e, d)    => Assert.IsTrue (tryInvoke(a, t, n, e, d).Result);
            Action<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>, Type> assertFailure = (a, t, n, e, d, x) => Assert.IsFalse(tryInvoke(a, t, n, e, d).Result);
<#
                if (interruptable)
                {
#>
            Action<Action, CancellationToken, int, ExceptionHandler, Func<<#= delayInputTypeParam #>, TimeSpan>, Type> assertError   = (a, t, n, e, d, x) => Assert.That.ThrowsExceptionAsync(() => tryInvoke(a, t, n, e, d), x).Wait();
<#
                }
#>

            Invoke_Action_Success         (assertSuccess, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t),  d     => d.Invoking += Expect.Nothing<<#= delayInputTypeParam #>>());
            Invoke_Action_Failure         (assertFailure, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t),  d     => d.Invoking += Expect.Nothing<<#= delayInputTypeParam #>>());
            Invoke_Action_EventualSuccess (assertSuccess, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
            Invoke_Action_EventualFailure (assertFailure, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
            Invoke_Action_RetriesExhausted(assertFailure, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
<#
                if (interruptable)
                {
#>

            Invoke_Action_Canceled_Delegate(assertError, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
            Invoke_Action_Canceled_Delay   (assertError, t => new FuncProxy<<#= delayInputTypeParam #>, TimeSpan>(<#= delayInputArgs #> => t), (d, t) => d.Invoking += Expect.<#= delayCallExpectation #>);
<#
                }
#>
        }

<#
            }
        }
    }
#>
        #endregion
    }
}
