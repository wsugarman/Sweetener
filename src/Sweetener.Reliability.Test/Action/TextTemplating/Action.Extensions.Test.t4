<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".tt.out" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="$(MSBuildProjectDirectory)\TextTemplating\Include.t4" #><#
    // Assume boolean variables called "async" and "interruptable" have been previously defined!
    string actionPrefix      = (interruptable ? "Interruptable" : string.Empty) + (async ? "Async" : string.Empty);
    string optionalAsync     = async ? "Async" : string.Empty;

    for (int parameterCount = 0; parameterCount <= MaxDelegateParameters; parameterCount++)
    {
        string optionalComma          = parameterCount > 0 ? ", " : string.Empty;
        string arguments              = GetArguments    (parameterCount);
        string parameters             = GetParameters   (typeArgs, parameterCount);
        string typeArguments          = GetTypeArguments(parameterCount);
        string typeArgumentsNoBracket = GetTypeArguments(parameterCount, includeBrackets: false);
        string typeArgumentsWithToken = "<" + typeArgumentsNoBracket + optionalComma + "CancellationToken>";
        string testArguments          = GetTestArguments(parameterCount);
        string typeParameters         = parameterCount == 0 ? string.Empty : "<" + GetTypeParameters(parameterCount) + ">";
        string suffix                 = parameterCount == 0 ? string.Empty : "T" + parameterCount;
        string proxyType              = (async ? "Async" : string.Empty)
                                        + "ActionProxy"
                                        + (interruptable ? (parameterCount == 0 ? "<CancellationToken>" : "<" + typeArgumentsNoBracket + ", CancellationToken>") : typeArguments);
#>
// Generated from <#= GetTemplateFileName() #>
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Sweetener.Reliability.Test
{
<#
        if (parameterCount == 0)
        {
#>
    [TestClass]
    public partial class <#= actionPrefix #>ActionExtensionsTest
<#
        }
        else
        {
#>
    partial class <#= actionPrefix #>ActionExtensionsTest
<#
        }
#>
    {
<#
        if (!async)
        {
#>
        [TestMethod]
        public void WithRetry<#= suffix #>_DelayPolicy()
        {
            <#= actionPrefix #>Action<#= typeArguments #> nullAction = null;
            <#= actionPrefix #>Action<#= typeArguments #> action     = <#= GetNoOpDelegate(parameterCount, async, interruptable) #>;
            Assert.ThrowsException<ArgumentNullException      >(() => nullAction.WithRetry( 4, ExceptionPolicies.Transient, DelayPolicies.None));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => action    .WithRetry(-2, ExceptionPolicies.Transient, DelayPolicies.None));
            Assert.ThrowsException<ArgumentNullException      >(() => action    .WithRetry( 4, null                       , DelayPolicies.None));
            Assert.ThrowsException<ArgumentNullException      >(() => action    .WithRetry( 4, ExceptionPolicies.Transient, (DelayPolicy)null ));

            Action<InterruptableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke;
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, InterruptableAction<#= typeArguments #>> withRetry = (a, r, e, d) => a.WithRetry(r, e, d);

            // Without Token
            invoke = (action<#= optionalComma #><#= arguments #>, token) => action(<#= arguments #>);

            WithRetry<#= suffix #>_Success         (withRetry, invoke);
            WithRetry<#= suffix #>_Failure         (withRetry, invoke);
            WithRetry<#= suffix #>_EventualSuccess (withRetry, invoke);
            WithRetry<#= suffix #>_EventualFailure (withRetry, invoke);
            WithRetry<#= suffix #>_RetriesExhausted(withRetry, invoke);

            // With Token
            invoke = (action<#= optionalComma #><#= arguments #>, token) => action(<#= arguments #><#= optionalComma #>token);

            WithRetry<#= suffix #>_Success         (withRetry, invoke);
            WithRetry<#= suffix #>_Failure         (withRetry, invoke);
            WithRetry<#= suffix #>_EventualSuccess (withRetry, invoke);
            WithRetry<#= suffix #>_EventualFailure (withRetry, invoke);
            WithRetry<#= suffix #>_RetriesExhausted(withRetry, invoke);
<#
        if (interruptable)
        {
#>
            WithRetry<#= suffix #>_Canceled_Action (withRetry, invoke);
<#
        }
#>
            WithRetry<#= suffix #>_Canceled_Delay  (withRetry, invoke);
        }

        [TestMethod]
        public void WithRetry<#= suffix #>_ComplexDelayPolicy()
        {
            <#= actionPrefix #>Action<#= typeArguments #> nullAction = null;
            <#= actionPrefix #>Action<#= typeArguments #> action     = <#= GetNoOpDelegate(parameterCount, async, interruptable) #>;
            Assert.ThrowsException<ArgumentNullException      >(() => nullAction.WithRetry( 4, ExceptionPolicies.Transient, (i, e) => TimeSpan.Zero ));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => action    .WithRetry(-2, ExceptionPolicies.Transient, (i, e) => TimeSpan.Zero ));
            Assert.ThrowsException<ArgumentNullException      >(() => action    .WithRetry( 4, null                       , (i, e) => TimeSpan.Zero ));
            Assert.ThrowsException<ArgumentNullException      >(() => action    .WithRetry( 4, ExceptionPolicies.Transient, (ComplexDelayPolicy)null));

            Action<InterruptableAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke;
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, InterruptableAction<#= typeArguments #>> withRetry = (a, r, e, d) => a.WithRetry(r, e, d);

            // Without Token
            invoke = (action<#= optionalComma #><#= arguments #>, token) => action(<#= arguments #>);

            WithRetry<#= suffix #>_Success         (withRetry, invoke);
            WithRetry<#= suffix #>_Failure         (withRetry, invoke);
            WithRetry<#= suffix #>_EventualSuccess (withRetry, invoke);
            WithRetry<#= suffix #>_EventualFailure (withRetry, invoke);
            WithRetry<#= suffix #>_RetriesExhausted(withRetry, invoke);

            // With Token
            invoke = (action<#= optionalComma #><#= arguments #>, token) => action(<#= arguments #><#= optionalComma #>token);

            WithRetry<#= suffix #>_Success         (withRetry, invoke);
            WithRetry<#= suffix #>_Failure         (withRetry, invoke);
            WithRetry<#= suffix #>_EventualSuccess (withRetry, invoke);
            WithRetry<#= suffix #>_EventualFailure (withRetry, invoke);
            WithRetry<#= suffix #>_RetriesExhausted(withRetry, invoke);
<#
        if (interruptable)
        {
#>
            WithRetry<#= suffix #>_Canceled_Action (withRetry, invoke);
<#
        }
#>
            WithRetry<#= suffix #>_Canceled_Delay  (withRetry, invoke);
        }

<#
        }
#>
        [TestMethod]
        public void WithAsyncRetry<#= suffix #>_DelayPolicy()
        {
            <#= actionPrefix #>Action<#= typeArguments #> nullAction = null;
            <#= actionPrefix #>Action<#= typeArguments #> action     = <#= GetNoOpDelegate(parameterCount, async, interruptable) #>;
            Assert.ThrowsException<ArgumentNullException      >(() => nullAction.WithAsyncRetry( 4, ExceptionPolicies.Transient, DelayPolicies.None));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => action    .WithAsyncRetry(-2, ExceptionPolicies.Transient, DelayPolicies.None));
            Assert.ThrowsException<ArgumentNullException      >(() => action    .WithAsyncRetry( 4, null                       , DelayPolicies.None));
            Assert.ThrowsException<ArgumentNullException      >(() => action    .WithAsyncRetry( 4, ExceptionPolicies.Transient, (DelayPolicy)null ));

            Action<InterruptableAsyncAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke;
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, InterruptableAsyncAction<#= typeArguments #>> withAsyncRetry = (a, r, e, d) => a.WithAsyncRetry(r, e, d);

            // Without Token
            invoke = (action<#= optionalComma #><#= arguments #>, token) => action(<#= arguments #>).Wait();

            WithRetry<#= suffix #>_Success         (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_Failure         (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_EventualSuccess (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_EventualFailure (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_RetriesExhausted(withAsyncRetry, invoke);

            // With Token
            invoke = (action<#= optionalComma #><#= arguments #>, token) => action(<#= arguments #><#= optionalComma #>token).Wait(<#= interruptable ? "token" : string.Empty #>);

            WithRetry<#= suffix #>_Success         (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_Failure         (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_EventualSuccess (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_EventualFailure (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_RetriesExhausted(withAsyncRetry, invoke);
<#
        if (interruptable)
        {
#>
            WithRetry<#= suffix #>_Canceled_Action (withAsyncRetry, invoke);
<#
        }
#>
            WithRetry<#= suffix #>_Canceled_Delay  (withAsyncRetry, invoke);
        }

        [TestMethod]
        public void WithAsyncRetry<#= suffix #>_ComplexDelayPolicy()
        {
            <#= actionPrefix #>Action<#= typeArguments #> nullAction = null;
            <#= actionPrefix #>Action<#= typeArguments #> action     = <#= GetNoOpDelegate(parameterCount, async, interruptable) #>;
            Assert.ThrowsException<ArgumentNullException      >(() => nullAction.WithAsyncRetry( 4, ExceptionPolicies.Transient, (i, e) => TimeSpan.Zero ));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => action    .WithAsyncRetry(-2, ExceptionPolicies.Transient, (i, e) => TimeSpan.Zero ));
            Assert.ThrowsException<ArgumentNullException      >(() => action    .WithAsyncRetry( 4, null                       , (i, e) => TimeSpan.Zero ));
            Assert.ThrowsException<ArgumentNullException      >(() => action    .WithAsyncRetry( 4, ExceptionPolicies.Transient, (ComplexDelayPolicy)null));

            Action<InterruptableAsyncAction<#= typeArguments #><#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke;
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, InterruptableAsyncAction<#= typeArguments #>> withAsyncRetry = (a, r, e, d) => a.WithAsyncRetry(r, e, d);

            // Without Token
            invoke = (action<#= optionalComma #><#= arguments #>, token) => action(<#= arguments #>).Wait();

            WithRetry<#= suffix #>_Success         (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_Failure         (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_EventualSuccess (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_EventualFailure (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_RetriesExhausted(withAsyncRetry, invoke);

            // With Token
            invoke = (action<#= optionalComma #><#= arguments #>, token) => action(<#= arguments #><#= optionalComma #>token).Wait(<#= interruptable ? "token" : string.Empty #>);

            WithRetry<#= suffix #>_Success         (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_Failure         (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_EventualSuccess (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_EventualFailure (withAsyncRetry, invoke);
            WithRetry<#= suffix #>_RetriesExhausted(withAsyncRetry, invoke);
<#
        if (interruptable)
        {
#>
            WithRetry<#= suffix #>_Canceled_Action (withAsyncRetry, invoke);
<#
        }
#>
            WithRetry<#= suffix #>_Canceled_Delay  (withAsyncRetry, invoke);
        }

        #region WithRetry<#= suffix #>_Success

        private void WithRetry<#= suffix #>_Success<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_Success(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, TimeSpan> delayPolicy = new FuncProxy<int, TimeSpan>();
                    delayPolicy.Invoking += Expect.Nothing<int>();
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_Success<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_Success(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, Exception, TimeSpan> delayPolicy = new FuncProxy<int, Exception, TimeSpan>();
                    delayPolicy.Invoking += Expect.Nothing<int, Exception>();
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_Success<TDelayPolicy, TAction>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke,
            Func<TDelayPolicy> delayPolicyFactory)
            where TDelayPolicy : DelegateProxy
        {
            // Create a "successful" user-defined action
            <#= proxyType #> action = new <#= proxyType #>(<#= GetNoOpDelegate(parameterCount, async, interruptable) #>);

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>();
            TDelayPolicy delayPolicy = delayPolicyFactory();

            // Create the reliable action
            TAction reliableAction = withRetry(
                action.Invoke<#= optionalAsync #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy);

            // Define expectations
<#
        if (interruptable || parameterCount > 0)
        {
#>
            action         .Invoking += Expect.Arguments<#= interruptable ? typeArgumentsWithToken : typeArguments #>(Arguments.Validate);
<#
        }
#>
            exceptionPolicy.Invoking += Expect.Nothing<Exception>();

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                invoke(reliableAction<#= optionalComma #><#= testArguments #>, tokenSource.Token);

            // Validate the number of calls
            Assert.AreEqual(1, action         .Calls);
            Assert.AreEqual(0, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= suffix #>_Failure

        private void WithRetry<#= suffix #>_Failure<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_Failure(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, TimeSpan> delayPolicy = new FuncProxy<int, TimeSpan>();
                    delayPolicy.Invoking += Expect.Nothing<int>();
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_Failure<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_Failure(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, Exception, TimeSpan> delayPolicy = new FuncProxy<int, Exception, TimeSpan>();
                    delayPolicy.Invoking += Expect.Nothing<int, Exception>();
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_Failure<TDelayPolicy, TAction>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke,
            Func<TDelayPolicy> delayPolicyFactory)
            where TDelayPolicy : DelegateProxy
        {
            // Create an "unsuccessful" user-defined action
            <#= proxyType #> action = new <#= proxyType #>(<#= GetThrowException<InvalidOperationException>(parameterCount, async, interruptable) #>);

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Fail<InvalidOperationException>().Invoke);
            TDelayPolicy delayPolicy = delayPolicyFactory();

            // Create the reliable action
            TAction reliableAction = withRetry(
                action.Invoke<#= optionalAsync #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy);

            // Define expectations
<#
        if (interruptable || parameterCount > 0)
        {
#>
            action         .Invoking += Expect.Arguments<#= interruptable ? typeArgumentsWithToken : typeArguments #>(Arguments.Validate);
<#
        }
#>
            exceptionPolicy.Invoking += Expect.Exception(typeof(InvalidOperationException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.That.ThrowsException<InvalidOperationException>(() => invoke(reliableAction<#= optionalComma #><#= testArguments #>, tokenSource.Token));

            // Validate the number of calls
            Assert.AreEqual(1, action         .Calls);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= suffix #>_EventualSuccess

        private void WithRetry<#= suffix #>_EventualSuccess<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_EventualSuccess(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, TimeSpan> delayPolicy = new FuncProxy<int, TimeSpan>(i => Constants.Delay);
                    delayPolicy.Invoking += Expect.Asc();
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_EventualSuccess<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_EventualSuccess(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, Exception, TimeSpan> delayPolicy = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);
                    delayPolicy.Invoking += Expect.ExceptionAsc(typeof(IOException));
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_EventualSuccess<TDelayPolicy, TAction>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke,
            Func<TDelayPolicy> delayPolicyFactory)
            where TDelayPolicy : DelegateProxy
        {
            // Create a "successful" user-defined action that completes after 1 IOException
            Action flakyAction = FlakyAction.Create<IOException>(1);
            <#= proxyType #> action = new <#= proxyType #>(<#= GetDelegate(parameterCount, "flakyAction", async, interruptable) #>);

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicy delayPolicy = delayPolicyFactory();

            // Create the reliable action
            TAction reliableAction = withRetry(
                action.Invoke<#= optionalAsync #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy);

            // Define expectations
<#
        if (interruptable || parameterCount > 0)
        {
#>
            action         .Invoking += Expect.ArgumentsAfterDelay<#= interruptable ? typeArgumentsWithToken : typeArguments #>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            action         .Invoking += Expect.AfterDelay<#= typeArguments #>(Constants.MinDelay);
<#
        }
#>
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                invoke(reliableAction<#= optionalComma #><#= testArguments #>, tokenSource.Token);

            // Validate the number of calls
            Assert.AreEqual(2, action         .Calls);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(1, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= suffix #>_EventualFailure

        private void WithRetry<#= suffix #>_EventualFailure<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_EventualFailure(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, TimeSpan> delayPolicy = new FuncProxy<int, TimeSpan>(i => Constants.Delay);
                    delayPolicy.Invoking += Expect.Asc();
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_EventualFailure<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_EventualFailure(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, Exception, TimeSpan> delayPolicy = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);
                    delayPolicy.Invoking += Expect.ExceptionAsc(typeof(IOException));
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_EventualFailure<TDelayPolicy, TAction>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke,
            Func<TDelayPolicy> delayPolicyFactory)
            where TDelayPolicy : DelegateProxy
        {
            // Create an "unsuccessful" user-defined action that fails after 2 transient exceptions
            Action flakyAction = FlakyAction.Create<IOException, InvalidOperationException>(2);
            <#= proxyType #> action = new <#= proxyType #>(<#= GetDelegate(parameterCount, "flakyAction", async, interruptable) #>);

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicy delayPolicy = delayPolicyFactory();

            // Create the reliable action
            TAction reliableAction = withRetry(
                action.Invoke<#= optionalAsync #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy);

            // Define expectations
<#
        if (interruptable || parameterCount > 0)
        {
#>
            action         .Invoking += Expect.ArgumentsAfterDelay<#= interruptable ? typeArgumentsWithToken : typeArguments #>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            action         .Invoking += Expect.AfterDelay<#= typeArguments #>(Constants.MinDelay);
<#
        }
#>
            exceptionPolicy.Invoking += Expect.Exceptions(typeof(IOException), typeof(InvalidOperationException), 2);

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.That.ThrowsException<InvalidOperationException>(() => invoke(reliableAction<#= optionalComma #><#= testArguments #>, tokenSource.Token));

            // Validate the number of calls
            Assert.AreEqual(3, action          .Calls);
            Assert.AreEqual(3, exceptionPolicy .Calls);
            Assert.AreEqual(2, delayPolicy     .Calls);
        }

        #endregion

        #region WithRetry<#= suffix #>_RetriesExhausted

        private void WithRetry<#= suffix #>_RetriesExhausted<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_RetriesExhausted(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, TimeSpan> delayPolicy = new FuncProxy<int, TimeSpan>(i => Constants.Delay);
                    delayPolicy.Invoking += Expect.Asc();
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_RetriesExhausted<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_RetriesExhausted(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, Exception, TimeSpan> delayPolicy = new FuncProxy<int, Exception, TimeSpan>((i, e) => Constants.Delay);
                    delayPolicy.Invoking += Expect.ExceptionAsc(typeof(IOException));
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_RetriesExhausted<TDelayPolicy, TAction>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke,
            Func<TDelayPolicy> delayPolicyFactory)
            where TDelayPolicy : DelegateProxy
        {
            // Create an "unsuccessful" user-defined action that exhausts the configured number of retries
            <#= proxyType #> action = new <#= proxyType #>(<#= GetThrowException<IOException>(parameterCount, async, interruptable) #>);

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicy delayPolicy = delayPolicyFactory();

            // Create the reliable action
            TAction reliableAction = withRetry(
                action.Invoke<#= optionalAsync #>,
                2,
                exceptionPolicy.Invoke,
                delayPolicy);

            // Define expectations
<#
        if (interruptable || parameterCount > 0)
        {
#>
            action         .Invoking += Expect.ArgumentsAfterDelay<#= interruptable ? typeArgumentsWithToken : typeArguments #>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            action         .Invoking += Expect.AfterDelay<#= typeArguments #>(Constants.MinDelay);
<#
        }
#>
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.That.ThrowsException<IOException>(() => invoke(reliableAction<#= optionalComma #><#= testArguments #>, tokenSource.Token));

            // Validate the number of calls
            Assert.AreEqual(3, action          .Calls);
            Assert.AreEqual(3, exceptionPolicy .Calls);
            Assert.AreEqual(2, delayPolicy     .Calls);
        }

        #endregion

<#
        if (interruptable)
        {
#>
        #region WithRetry<#= suffix #>_Canceled_Action

        private void WithRetry<#= suffix #>_Canceled_Action<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_Canceled_Action(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, TimeSpan> delayPolicy = new FuncProxy<int, TimeSpan>();
                    delayPolicy.Invoking += Expect.Asc();
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_Canceled_Action<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_Canceled_Action(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, Exception, TimeSpan> delayPolicy = new FuncProxy<int, Exception, TimeSpan>();
                    delayPolicy.Invoking += Expect.ExceptionAsc(typeof(IOException));
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_Canceled_Action<TDelayPolicy, TAction>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke,
            Func<TDelayPolicy> delayPolicyFactory)
            where TDelayPolicy : DelegateProxy
        {
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            // Create a user-defined action that will throw an exception depending on whether its canceled
            <#= proxyType #> action = new <#= proxyType #>(<#= async ? "async " : string.Empty #>(<#= arguments #><#= optionalComma #>token) =>
            {
<#
            if (async)
            {
#>
                await Task.CompletedTask;
<#
            }
#>
                token.ThrowIfCancellationRequested();
                throw new IOException();
            });

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicy delayPolicy = delayPolicyFactory();

            // Create the reliable action
            TAction reliableAction = withRetry(
                action.Invoke<#= optionalAsync #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy);

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            action         .Invoking += Expect.ArgumentsAfterDelay<#= typeArgumentsWithToken #>(Arguments.Validate, Constants.MinDelay);
<#
        }
#>
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));

            // Cancel the action on its 2nd attempt
            action         .Invoking += (<#= arguments #><#= optionalComma #>t, c) =>
            {
                if (c.Calls == 2)
                    tokenSource.Cancel();
            };

            // Invoke
            Assert.That.ThrowsException<OperationCanceledException>(() => invoke(reliableAction<#= optionalComma #><#= testArguments #>, tokenSource.Token), allowedDerivedTypes: true);

            // Validate the number of calls
            Assert.AreEqual(2, action         .Calls);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(1, delayPolicy    .Calls);
        }

        #endregion

<#
        }
#>
        #region WithRetry<#= suffix #>_Canceled_Delay

        private void WithRetry<#= suffix #>_Canceled_Delay<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, DelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_Canceled_Delay(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, TimeSpan> delayPolicy = new FuncProxy<int, TimeSpan>();
                    delayPolicy.Invoking += Expect.Asc();
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_Canceled_Delay<T>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, ComplexDelayPolicy, T> withRetry,
            Action<T<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke)
            => WithRetry<#= suffix #>_Canceled_Delay(
                (a, r, e, d) => withRetry(a, r, e, d.Invoke),
                invoke,
                () =>
                {
                    FuncProxy<int, Exception, TimeSpan> delayPolicy = new FuncProxy<int, Exception, TimeSpan>();
                    delayPolicy.Invoking += Expect.ExceptionAsc(typeof(IOException));
                    return delayPolicy;
                });

        private void WithRetry<#= suffix #>_Canceled_Delay<TDelayPolicy, TAction>(
            Func<<#= actionPrefix #>Action<#= typeArguments #>, int, ExceptionPolicy, TDelayPolicy, TAction> withRetry,
            Action<TAction<#= optionalComma #><#= typeArgumentsNoBracket #>, CancellationToken> invoke,
            Func<TDelayPolicy> delayPolicyFactory)
            where TDelayPolicy : DelegateProxy
        {
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            // Create an "unsuccessful" user-defined action that continues to fail with transient exceptions until it's canceled
            <#= proxyType #> action = new <#= proxyType #>(<#= GetThrowException<IOException>(parameterCount, async, interruptable) #>);

            // Declare the various policy and event handler proxies
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicy delayPolicy = delayPolicyFactory();

            // Create the reliable InterruptableAction
            TAction reliableAction = withRetry(
                action.Invoke<#= optionalAsync #>,
                Retries.Infinite,
                exceptionPolicy.Invoke,
                delayPolicy);

            // Define expectations
<#
        if (interruptable || parameterCount > 0)
        {
#>
            action         .Invoking += Expect.ArgumentsAfterDelay<#= interruptable ? typeArgumentsWithToken : typeArguments #>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            action         .Invoking += Expect.AfterDelay<#= typeArguments #>(Constants.MinDelay);
<#
        }
#>
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));

            // Cancel the delay on its 2nd invocation
            // (We use the exception policy because there's no Invoking event on TDelay)
            exceptionPolicy.Invoking += (e, c) =>
            {
                if (c.Calls == 2)
                    tokenSource.Cancel();
            };

            // Begin the invocation
            Assert.That.ThrowsException<OperationCanceledException>(() => invoke(reliableAction<#= optionalComma #><#= testArguments #>, tokenSource.Token), allowedDerivedTypes: true);

            // Validate the number of calls
            Assert.AreEqual(2, action          .Calls);
            Assert.AreEqual(2, exceptionPolicy .Calls);
            Assert.AreEqual(2, delayPolicy     .Calls);
        }

        #endregion
    }
}
<#
        string fileName = parameterCount == 0 ? $"{actionPrefix}Action.Extensions.Test.cs" : $"{actionPrefix}Action.Extensions.T{parameterCount}.Test.cs";
        SaveOutput(fileName);
    }
#>
<#= GetTemplateFileName() #> ran successfully
