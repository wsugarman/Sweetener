<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".tt.out" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="$(MSBuildProjectDirectory)\TextTemplating\Include.t4" #><#
    for (int parameterCount = 0; parameterCount <= MaxDelegateParameters; parameterCount++)
    {
        string optionalComma      = parameterCount > 0 ? ", " : string.Empty;
        string arguments          = GetArguments     (          parameterCount);
        string parameters         = GetParameters    (typeArgs, parameterCount);
        string argumentValues     = GetArgumentValues(          parameterCount);
        string typeArguments      = GetTypeArguments (          parameterCount);
        string baseSuffix         = "T" + (parameterCount + 1);
#>
// Generated from <#= GetTemplateFileName() #>
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Sweetener.Reliability.Test
{
    // Define type aliases for the various generic types used below as they can become pretty cumbersome
    using TestFunc                        = Func     <#= Enclose(GetTypeArguments(parameterCount, async: false, interruptable: false, outputType: "int"), BracketType.AngleBrackets) #>;
    using InterruptableTestFunc           = Func     <#= Enclose(GetTypeArguments(parameterCount, async: false, interruptable: true , outputType: "int"), BracketType.AngleBrackets) #>;
    using AsyncTestFunc                   = Func     <#= Enclose(GetTypeArguments(parameterCount, async: true , interruptable: false, outputType: "int"), BracketType.AngleBrackets) #>;
    using InterruptableAsyncTestFunc      = Func     <#= Enclose(GetTypeArguments(parameterCount, async: true , interruptable: true , outputType: "int"), BracketType.AngleBrackets) #>;
    using TestFuncProxy                   = FuncProxy<#= Enclose(GetTypeArguments(parameterCount, async: false, interruptable: false, outputType: "int"), BracketType.AngleBrackets) #>;
    using InterruptableTestFuncProxy      = FuncProxy<#= Enclose(GetTypeArguments(parameterCount, async: false, interruptable: true , outputType: "int"), BracketType.AngleBrackets) #>;
    using AsyncTestFuncProxy              = FuncProxy<#= Enclose(GetTypeArguments(parameterCount, async: true , interruptable: false, outputType: "int"), BracketType.AngleBrackets) #>;
    using InterruptableAsyncTestFuncProxy = FuncProxy<#= Enclose(GetTypeArguments(parameterCount, async: true , interruptable: true , outputType: "int"), BracketType.AngleBrackets) #>;
    using DelayPolicyProxy                = FuncProxy<int, TimeSpan>;
    using ComplexDelayPolicyProxy         = FuncProxy<int, int, Exception, TimeSpan>;

<#
        if (parameterCount == 0)
        {
#>
    [TestClass]
    public partial class FuncExtensionsTest
<#
        }
        else
        {
#>
    partial class FuncExtensionsTest
<#
        }
#>
    {
<#
        foreach (bool async in new bool[] { false, true })
        {
            string optionalAsync = async ? "Async" : string.Empty;

            foreach (bool interruptable in new bool[] { false, true })
            {
                string inputTypeArguments = Enclose(GetTypeArguments(parameterCount, async: false, interruptable: interruptable), BracketType.AngleBrackets);
                string optionalToken      = interruptable ?                 "token" : "CancellationToken.None";
                string optionalCommaToken = interruptable ? optionalComma + "token" : string.Empty;

                foreach (bool passResultPolicy in new bool[] { false, true })
                {
                    foreach (bool useComplexPolicy in new bool[] { false, true })
                    {
                        string inputFuncType          = (interruptable ? "Interruptable" : string.Empty) + (async ? "Async" : string.Empty) + "TestFunc";
                        string delayPolicyFunc        = useComplexPolicy ? "Func<int, int, Exception, TimeSpan>" : "Func<int, TimeSpan>";
                        string delayPolicyTypeProxy   = (useComplexPolicy ? "ComplexDelayPolicy" : "DelayPolicy") + "Proxy";
                        string noDelayPolicy          = useComplexPolicy ? "(i, r, e) => TimeSpan.Zero" : "DelayPolicies.None";
                        string delayPolicyExpectation = useComplexPolicy ? (passResultPolicy ? "AlternatingAsc(r, e)" : "OnlyExceptionAsc<int>(e)") : "Asc()";
                        string testSuffix             = baseSuffix
                            + (async            ? "_Async"              : string.Empty)
                            + (interruptable    ? "_WithToken"          : string.Empty)
                            + (passResultPolicy ? "_ResultPolicy"       : string.Empty)
                            + (useComplexPolicy ? "_ComplexDelayPolicy" : "_DelayPolicy");
#>
        [TestMethod]
        public void With<#= optionalAsync #>Retry<#= testSuffix #>()
        {
            <#= inputFuncType #> nullFunc = null;
            <#= inputFuncType #> func     = <#= GetExpressionDelegate(parameterCount, "12345", async, interruptable) #>;
<#
                        if (passResultPolicy)
                        {
#>
            Assert.ThrowsException<ArgumentNullException      >(() => nullFunc.With<#= optionalAsync #>Retry( 4, r => ResultKind.Successful, ExceptionPolicies.Transient, <#= noDelayPolicy #>));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => func    .With<#= optionalAsync #>Retry(-2, r => ResultKind.Successful, ExceptionPolicies.Transient, <#= noDelayPolicy #>));
            Assert.ThrowsException<ArgumentNullException      >(() => func    .With<#= optionalAsync #>Retry( 4, null                      , ExceptionPolicies.Transient, <#= noDelayPolicy #>));
            Assert.ThrowsException<ArgumentNullException      >(() => func    .With<#= optionalAsync #>Retry( 4, r => ResultKind.Successful, null                       , <#= noDelayPolicy #>));
            Assert.ThrowsException<ArgumentNullException      >(() => func    .With<#= optionalAsync #>Retry( 4, r => ResultKind.Successful, ExceptionPolicies.Transient, (<#= useComplexPolicy ? "ComplexDelayPolicy<int>" : "DelayPolicy" #>)null));
<#
                        }
                        else
                        {
#>
            Assert.ThrowsException<ArgumentNullException      >(() => nullFunc.With<#= optionalAsync #>Retry( 4, ExceptionPolicies.Transient, <#= noDelayPolicy #>));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => func    .With<#= optionalAsync #>Retry(-2, ExceptionPolicies.Transient, <#= noDelayPolicy #>));
            Assert.ThrowsException<ArgumentNullException      >(() => func    .With<#= optionalAsync #>Retry( 4, null                       , <#= noDelayPolicy #>));
            Assert.ThrowsException<ArgumentNullException      >(() => func    .With<#= optionalAsync #>Retry( 4, ExceptionPolicies.Transient, (<#= useComplexPolicy ? "ComplexDelayPolicy<int>" : "DelayPolicy" #>)null));
<#
                        }
#>

            // Create the delegates necessary to test the WithRetry overload
            Func<Func<CancellationToken, int>, <#= inputFuncType #>Proxy> funcFactory = f => new <#= inputFuncType #>Proxy(<#= async ? "async " : string.Empty #>(<#= arguments #><#= optionalCommaToken #>) => <#= async ? $"{{ await Task.CompletedTask.ConfigureAwait(false); return f({optionalToken}); }}" : $"f({optionalToken})" #>);
            Func<TimeSpan, <#= delayPolicyTypeProxy #>> delayPolicyFactory = t => new <#= delayPolicyTypeProxy #>((i<#= useComplexPolicy ? ", r, e" : string.Empty #>) => t);
            Func<<#= inputFuncType #>, int, ResultPolicy<int>, ExceptionPolicy, <#= delayPolicyFunc #>, <#= inputFuncType #>> with<#= optionalAsync #>Retry = (f, m, r, e, d) => f.With<#= optionalAsync #>Retry(m<#= passResultPolicy ? ", r" : string.Empty #>, e, d.Invoke);
            Func<<#= inputFuncType #><#= optionalComma #><#= typeArguments #>, CancellationToken, int> invoke = (f<#= optionalComma #><#= arguments #>, token) => f(<#= arguments #><#= optionalCommaToken #>)<#= async ? ".Result" : string.Empty #>;

            Action<<#= inputFuncType #>Proxy>           observeFunc      = <#= interruptable || parameterCount > 0 ? $"f          => f.Invoking += Expect.Arguments{inputTypeArguments}(Arguments.Validate)" : "null" #>;
            Action<<#= inputFuncType #>Proxy, TimeSpan> observeFuncDelay = (f, delay) => f.Invoking += Expect.<#= interruptable || parameterCount > 0 ? $"ArgumentsAfterDelay{inputTypeArguments}(Arguments.Validate, delay)" : $"AfterDelay{inputTypeArguments}(delay)" #>;

            // Success
            WithRetry<#= baseSuffix #>_Success        (funcFactory, delayPolicyFactory, with<#= optionalAsync #>Retry, invoke, observeFunc     ,  d        => d.Invoking += Expect.Nothing<int<#= useComplexPolicy ? ", int, Exception" : string.Empty #>>(), passResultPolicy: <#= passResultPolicy.ToString().ToLowerInvariant() #>);
            WithRetry<#= baseSuffix #>_EventualSuccess(funcFactory, delayPolicyFactory, with<#= optionalAsync #>Retry, invoke, observeFuncDelay, (d, r, e) => d.Invoking += Expect.<#= delayPolicyExpectation #>, passResultPolicy: <#= passResultPolicy.ToString().ToLowerInvariant() #>);

<#
                        if (passResultPolicy)
                        {
#>
            // Failure (Result)
            WithRetry<#= baseSuffix #>_Failure_Result         (funcFactory, delayPolicyFactory, with<#= optionalAsync #>Retry, invoke, observeFunc     ,  d        => d.Invoking += Expect.Nothing<int<#= useComplexPolicy ? ", int, Exception" : string.Empty #>>());
            WithRetry<#= baseSuffix #>_EventualFailure_Result (funcFactory, delayPolicyFactory, with<#= optionalAsync #>Retry, invoke, observeFuncDelay, (d, r, e) => d.Invoking += Expect.<#= delayPolicyExpectation #>);
            WithRetry<#= baseSuffix #>_RetriesExhausted_Result(funcFactory, delayPolicyFactory, with<#= optionalAsync #>Retry, invoke, observeFuncDelay, (d, r, e) => d.Invoking += Expect.<#= delayPolicyExpectation #>);

<#
                        }
#>
            // Failure (Exception)
            WithRetry<#= baseSuffix #>_Failure_Exception         (funcFactory, delayPolicyFactory, with<#= optionalAsync #>Retry, invoke, observeFunc     ,  d        => d.Invoking += Expect.Nothing<int<#= useComplexPolicy ? ", int, Exception" : string.Empty #>>(), passResultPolicy: <#= passResultPolicy.ToString().ToLowerInvariant() #>);
            WithRetry<#= baseSuffix #>_EventualFailure_Exception (funcFactory, delayPolicyFactory, with<#= optionalAsync #>Retry, invoke, observeFuncDelay, (d, r, e) => d.Invoking += Expect.<#= delayPolicyExpectation #>, passResultPolicy: <#= passResultPolicy.ToString().ToLowerInvariant() #>);
            WithRetry<#= baseSuffix #>_RetriesExhausted_Exception(funcFactory, delayPolicyFactory, with<#= optionalAsync #>Retry, invoke, observeFuncDelay, (d, r, e) => d.Invoking += Expect.<#= delayPolicyExpectation #>, passResultPolicy: <#= passResultPolicy.ToString().ToLowerInvariant() #>);
<#
                        if (interruptable)
                        {
#>

            // Cancel
            WithRetry<#= baseSuffix #>_Canceled_Func (funcFactory, delayPolicyFactory, with<#= optionalAsync #>Retry, invoke, observeFuncDelay, (d, r, e) => d.Invoking += Expect.<#= delayPolicyExpectation #>, passResultPolicy: <#= passResultPolicy.ToString().ToLowerInvariant() #>);
            WithRetry<#= baseSuffix #>_Canceled_Delay(funcFactory, delayPolicyFactory, with<#= optionalAsync #>Retry, invoke, observeFuncDelay, (d, r, e) => d.Invoking += Expect.<#= delayPolicyExpectation #>, passResultPolicy: <#= passResultPolicy.ToString().ToLowerInvariant() #>);
<#
                        }
#>
        }

<#
                    }
                }
            }
        }
#>
        #region WithRetry<#= baseSuffix #>_Success

        private void WithRetry<#= baseSuffix #>_Success<TFunc, TDelayPolicy, TFuncProxy, TDelayPolicyProxy>(
            Func<Func<CancellationToken, int>, TFuncProxy> funcFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TFunc, int, ResultPolicy<int>, ExceptionPolicy, TDelayPolicy, TFunc> withRetry,
            Func<TFunc<#= optionalComma #><#= typeArguments #>, CancellationToken, int> invoke,
            Action<TFuncProxy> observeFunc,
            Action<TDelayPolicyProxy> observeDelayPolicy,
            bool passResultPolicy)
            where TFunc             : Delegate
            where TDelayPolicy      : Delegate
            where TFuncProxy        : DelegateProxy<TFunc>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create a "successful" user-defined function
            TFuncProxy func = funcFactory(t => 200);

            // Declare the various policy and event handler proxies
            FuncProxy<int, ResultKind> resultPolicy    = new FuncProxy<int, ResultKind>(n => n == 200 ? ResultKind.Successful : ResultKind.Fatal);
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>();
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(TimeSpan.Zero);

            // Create the reliable function
            TFunc reliableFunc = withRetry(
                func.Proxy,
                Retries.Infinite,
                resultPolicy   .Invoke,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            resultPolicy   .Invoking += Expect.Result(200);
            exceptionPolicy.Invoking += Expect.Nothing<Exception>();

            observeFunc       ?.Invoke(func);
            observeDelayPolicy?.Invoke(delayPolicy);

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.AreEqual(200, invoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token));

            // Validate the number of calls
            int x = passResultPolicy ? 1 : 0;
            Assert.AreEqual(1, func           .Calls);
            Assert.AreEqual(x, resultPolicy   .Calls);
            Assert.AreEqual(0, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_Failure_Result

        private void WithRetry<#= baseSuffix #>_Failure_Result<TFunc, TDelayPolicy, TFuncProxy, TDelayPolicyProxy>(
            Func<Func<CancellationToken, int>, TFuncProxy> funcFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TFunc, int, ResultPolicy<int>, ExceptionPolicy, TDelayPolicy, TFunc> withRetry,
            Func<TFunc<#= optionalComma #><#= typeArguments #>, CancellationToken, int> invoke,
            Action<TFuncProxy> observeFunc,
            Action<TDelayPolicyProxy> observeDelayPolicy)
            where TFunc             : Delegate
            where TDelayPolicy      : Delegate
            where TFuncProxy        : DelegateProxy<TFunc>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create an "unsuccessful" user-defined func
            TFuncProxy func = funcFactory(t => 500);

            // Declare the various policy and event handler proxies
            FuncProxy<int, ResultKind> resultPolicy    = new FuncProxy<int, ResultKind>(n => n == 200 ? ResultKind.Successful : ResultKind.Fatal);
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>();
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(TimeSpan.Zero);

            // Create the reliable function
            TFunc reliableFunc = withRetry(
                func.Proxy,
                Retries.Infinite,
                resultPolicy   .Invoke,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            resultPolicy   .Invoking += Expect.Result(500);
            exceptionPolicy.Invoking += Expect.Nothing<Exception>();

            observeFunc       ?.Invoke(func);
            observeDelayPolicy?.Invoke(delayPolicy);

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.AreEqual(500, invoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token));

            // Validate the number of calls
            Assert.AreEqual(1, func           .Calls);
            Assert.AreEqual(1, resultPolicy   .Calls);
            Assert.AreEqual(0, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_Failure_Exception

        private void WithRetry<#= baseSuffix #>_Failure_Exception<TFunc, TDelayPolicy, TFuncProxy, TDelayPolicyProxy>(
            Func<Func<CancellationToken, int>, TFuncProxy> funcFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TFunc, int, ResultPolicy<int>, ExceptionPolicy, TDelayPolicy, TFunc> withRetry,
            Func<TFunc<#= optionalComma #><#= typeArguments #>, CancellationToken, int> invoke,
            Action<TFuncProxy> observeFunc,
            Action<TDelayPolicyProxy> observeDelayPolicy,
            bool passResultPolicy)
            where TFunc             : Delegate
            where TDelayPolicy      : Delegate
            where TFuncProxy        : DelegateProxy<TFunc>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create an "unsuccessful" user-defined func
            TFuncProxy func = funcFactory(t => throw new InvalidOperationException());

            // Declare the various policy and event handler proxies
            FuncProxy<int, ResultKind> resultPolicy    = new FuncProxy<int, ResultKind>();
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>();
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(TimeSpan.Zero);

            // Create the reliable function
            TFunc reliableFunc = withRetry(
                func.Proxy,
                Retries.Infinite,
                resultPolicy   .Invoke,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            resultPolicy   .Invoking += Expect.Nothing<int>();
            exceptionPolicy.Invoking += Expect.Exception(typeof(InvalidOperationException));

            observeFunc       ?.Invoke(func);
            observeDelayPolicy?.Invoke(delayPolicy);

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.That.ThrowsException<InvalidOperationException>(() => invoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token));

            // Validate the number of calls
            Assert.AreEqual(1, func           .Calls);
            Assert.AreEqual(0, resultPolicy   .Calls);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(0, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_EventualSuccess

        private void WithRetry<#= baseSuffix #>_EventualSuccess<TFunc, TDelayPolicy, TFuncProxy, TDelayPolicyProxy>(
            Func<Func<CancellationToken, int>, TFuncProxy> funcFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TFunc, int, ResultPolicy<int>, ExceptionPolicy, TDelayPolicy, TFunc> withRetry,
            Func<TFunc<#= optionalComma #><#= typeArguments #>, CancellationToken, int> invoke,
            Action<TFuncProxy, TimeSpan> observeFunc,
            Action<TDelayPolicyProxy, int, Type> observeDelayPolicy,
            bool passResultPolicy)
            where TFunc             : Delegate
            where TDelayPolicy      : Delegate
            where TFuncProxy        : DelegateProxy<TFunc>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create a "successful" user-defined action that completes after either
            // (1) 2 IOExceptions OR
            // (2) an IOException and a transient 418 result
            Func<int> flakyFunc = passResultPolicy
                ? FlakyFunc.Create<int, IOException>(418, 200, 2)
                : FlakyFunc.Create<int, IOException>(     200, 2);
            TFuncProxy func = funcFactory(t => flakyFunc());

            // Declare the various policy and event handler proxies
            FuncProxy<int, ResultKind> resultPolicy = new FuncProxy<int, ResultKind>(r =>
                r switch
                {
                    418 => ResultKind.Transient,
                    200 => ResultKind.Successful,
                    _   => ResultKind.Fatal,
                });
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(Constants.Delay);

            // Create the reliable function
            TFunc reliableFunc = withRetry(
                func.Proxy,
                Retries.Infinite,
                resultPolicy   .Invoke,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            resultPolicy   .Invoking += Expect.Results(418, 200, 1);
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));

            observeFunc       ?.Invoke(func, Constants.MinDelay);
            observeDelayPolicy?.Invoke(delayPolicy, 418, typeof(IOException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.AreEqual(200, invoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token));

            // Validate the number of calls
            int x = passResultPolicy ? 2 : 0;
            int y = passResultPolicy ? 1 : 2;
            Assert.AreEqual(3, func           .Calls);
            Assert.AreEqual(x, resultPolicy   .Calls);
            Assert.AreEqual(y, exceptionPolicy.Calls);
            Assert.AreEqual(2, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_EventualFailure_Result

        private void WithRetry<#= baseSuffix #>_EventualFailure_Result<TFunc, TDelayPolicy, TFuncProxy, TDelayPolicyProxy>(
            Func<Func<CancellationToken, int>, TFuncProxy> funcFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TFunc, int, ResultPolicy<int>, ExceptionPolicy, TDelayPolicy, TFunc> withRetry,
            Func<TFunc<#= optionalComma #><#= typeArguments #>, CancellationToken, int> invoke,
            Action<TFuncProxy, TimeSpan> observeFunc,
            Action<TDelayPolicyProxy, int, Type> observeDelayPolicy)
            where TFunc             : Delegate
            where TDelayPolicy      : Delegate
            where TFuncProxy        : DelegateProxy<TFunc>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create an "unsuccessful" user-defined action that completes after a transient result and exception
            Func<int> flakyFunc = FlakyFunc.Create<int, IOException>(418, 500, 2);
            TFuncProxy func = funcFactory(t => flakyFunc());

            // Declare the various policy and event handler proxies
            FuncProxy<int, ResultKind> resultPolicy = new FuncProxy<int, ResultKind>(r =>
                r switch
                {
                    418 => ResultKind.Transient,
                    500 => ResultKind.Fatal,
                    _   => ResultKind.Successful,
                });
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(Constants.Delay);

            // Create the reliable function
            TFunc reliableFunc = withRetry(
                func.Proxy,
                Retries.Infinite,
                resultPolicy   .Invoke,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            resultPolicy   .Invoking += Expect.Results(418, 500, 1);
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));

            observeFunc       ?.Invoke(func, Constants.MinDelay);
            observeDelayPolicy?.Invoke(delayPolicy, 418, typeof(IOException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.AreEqual(500, invoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token));

            // Validate the number of calls
            Assert.AreEqual(3, func           .Calls);
            Assert.AreEqual(2, resultPolicy   .Calls);
            Assert.AreEqual(1, exceptionPolicy.Calls);
            Assert.AreEqual(2, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_EventualFailure_Exception

        private void WithRetry<#= baseSuffix #>_EventualFailure_Exception<TFunc, TDelayPolicy, TFuncProxy, TDelayPolicyProxy>(
            Func<Func<CancellationToken, int>, TFuncProxy> funcFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TFunc, int, ResultPolicy<int>, ExceptionPolicy, TDelayPolicy, TFunc> withRetry,
            Func<TFunc<#= optionalComma #><#= typeArguments #>, CancellationToken, int> invoke,
            Action<TFuncProxy, TimeSpan> observeFunc,
            Action<TDelayPolicyProxy, int, Type> observeDelayPolicy,
            bool passResultPolicy)
            where TFunc             : Delegate
            where TDelayPolicy      : Delegate
            where TFuncProxy        : DelegateProxy<TFunc>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create an "unsuccessful" user-defined action that completes after either
            // (1) 2 IOExceptions OR
            // (2) an IOException and a transient 418 result
            Func<int> flakyFunc = passResultPolicy
                ? FlakyFunc.Create<int, IOException, InvalidOperationException>(418, 2)
                : FlakyFunc.Create<int, IOException, InvalidOperationException>(     2);
            TFuncProxy func = funcFactory(t => flakyFunc());

            // Declare the various policy and event handler proxies
            FuncProxy<int, ResultKind> resultPolicy    = new FuncProxy<int, ResultKind>(r => r == 418 ? ResultKind.Transient : ResultKind.Successful);
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(Constants.Delay);

            // Create the reliable function
            TFunc reliableFunc = withRetry(
                func.Proxy,
                Retries.Infinite,
                resultPolicy   .Invoke,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            resultPolicy   .Invoking += Expect.Result(418);
            exceptionPolicy.Invoking += Expect.Exceptions(typeof(IOException), typeof(InvalidOperationException), passResultPolicy ? 1 : 2);

            observeFunc       ?.Invoke(func, Constants.MinDelay);
            observeDelayPolicy?.Invoke(delayPolicy, 418, typeof(IOException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.That.ThrowsException<InvalidOperationException>(() => invoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token));

            // Validate the number of calls
            int x = passResultPolicy ? 1 : 0;
            int y = passResultPolicy ? 2 : 3;
            Assert.AreEqual(3, func           .Calls);
            Assert.AreEqual(x, resultPolicy   .Calls);
            Assert.AreEqual(y, exceptionPolicy.Calls);
            Assert.AreEqual(2, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_RetriesExhausted_Result

        private void WithRetry<#= baseSuffix #>_RetriesExhausted_Result<TFunc, TDelayPolicy, TFuncProxy, TDelayPolicyProxy>(
            Func<Func<CancellationToken, int>, TFuncProxy> funcFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TFunc, int, ResultPolicy<int>, ExceptionPolicy, TDelayPolicy, TFunc> withRetry,
            Func<TFunc<#= optionalComma #><#= typeArguments #>, CancellationToken, int> invoke,
            Action<TFuncProxy, TimeSpan> observeFunc,
            Action<TDelayPolicyProxy, int, Type> observeDelayPolicy)
            where TFunc             : Delegate
            where TDelayPolicy      : Delegate
            where TFuncProxy        : DelegateProxy<TFunc>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create an "unsuccessful" user-defined action that eventually exhausts all of its retries
            Func<int> flakyFunc = FlakyFunc.Create<int, IOException>(418);
            TFuncProxy func = funcFactory(t => flakyFunc());

            // Declare the various policy and event handler proxies
            FuncProxy<int, ResultKind> resultPolicy = new FuncProxy<int, ResultKind>(r => r == 418 ? ResultKind.Transient : ResultKind.Fatal);
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(Constants.Delay);

            // Create the reliable function
            TFunc reliableFunc = withRetry(
                func.Proxy,
                3,
                resultPolicy   .Invoke,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            resultPolicy   .Invoking += Expect.Result(418);
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));

            observeFunc       ?.Invoke(func, Constants.MinDelay);
            observeDelayPolicy?.Invoke(delayPolicy, 418, typeof(IOException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.AreEqual(418, invoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token));

            // Validate the number of calls
            Assert.AreEqual(4, func           .Calls);
            Assert.AreEqual(2, resultPolicy   .Calls);
            Assert.AreEqual(2, exceptionPolicy.Calls);
            Assert.AreEqual(3, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_RetriesExhausted_Exception

        private void WithRetry<#= baseSuffix #>_RetriesExhausted_Exception<TFunc, TDelayPolicy, TFuncProxy, TDelayPolicyProxy>(
            Func<Func<CancellationToken, int>, TFuncProxy> funcFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TFunc, int, ResultPolicy<int>, ExceptionPolicy, TDelayPolicy, TFunc> withRetry,
            Func<TFunc<#= optionalComma #><#= typeArguments #>, CancellationToken, int> invoke,
            Action<TFuncProxy, TimeSpan> observeFunc,
            Action<TDelayPolicyProxy, int, Type> observeDelayPolicy,
            bool passResultPolicy)
            where TFunc             : Delegate
            where TDelayPolicy      : Delegate
            where TFuncProxy        : DelegateProxy<TFunc>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            // Create an "unsuccessful" user-defined action that eventually exhausts all of its retries
            Func<int> flakyFunc = passResultPolicy
                ? FlakyFunc.Create<int, IOException>(418)
                : () => throw new IOException();
            TFuncProxy func = funcFactory(t => flakyFunc());

            // Declare the various policy and event handler proxies
            FuncProxy<int, ResultKind> resultPolicy    = new FuncProxy<int, ResultKind>(r => r == 418 ? ResultKind.Transient : ResultKind.Successful);
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Retry<IOException>().Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(Constants.Delay);

            // Create the reliable function
            TFunc reliableFunc = withRetry(
                func.Proxy,
                2,
                resultPolicy   .Invoke,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            resultPolicy   .Invoking += Expect.Result(418);
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));

            observeFunc       ?.Invoke(func, Constants.MinDelay);
            observeDelayPolicy?.Invoke(delayPolicy, 418, typeof(IOException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                Assert.That.ThrowsException<IOException>(() => invoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token));

            // Validate the number of calls
            int x = passResultPolicy ? 1 : 0;
            int y = passResultPolicy ? 2 : 3;
            Assert.AreEqual(3, func           .Calls);
            Assert.AreEqual(x, resultPolicy   .Calls);
            Assert.AreEqual(y, exceptionPolicy.Calls);
            Assert.AreEqual(2, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_Canceled_Func

        private void WithRetry<#= baseSuffix #>_Canceled_Func<TFunc, TDelayPolicy, TFuncProxy, TDelayPolicyProxy>(
            Func<Func<CancellationToken, int>, TFuncProxy> funcFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TFunc, int, ResultPolicy<int>, ExceptionPolicy, TDelayPolicy, TFunc> withRetry,
            Func<TFunc<#= optionalComma #><#= typeArguments #>, CancellationToken, int> invoke,
            Action<TFuncProxy, TimeSpan> observeFunc,
            Action<TDelayPolicyProxy, int, Type> observeDelayPolicy,
            bool passResultPolicy)
            where TFunc             : Delegate
            where TDelayPolicy      : Delegate
            where TFuncProxy        : DelegateProxy<TFunc>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            // Create a user-defined action that will throw an exception depending on whether it's canceled
            Func<int> flakyFunc = passResultPolicy ? FlakyFunc.Create<int, IOException>(418) : () => throw new IOException();
            TFuncProxy func = funcFactory(t =>
            {
                t.ThrowIfCancellationRequested();
                return flakyFunc();
            });

            // Declare the various policy and event handler proxies
            FuncProxy<int, ResultKind> resultPolicy    = new FuncProxy<int, ResultKind>(r => r == 418 ? ResultKind.Transient : ResultKind.Successful);
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Transient.Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(Constants.Delay);

            // Create the reliable function
            TFunc reliableFunc = withRetry(
                func.Proxy,
                Retries.Infinite,
                resultPolicy   .Invoke,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            resultPolicy   .Invoking += Expect.Result(418);
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));

            observeFunc       ?.Invoke(func, Constants.MinDelay);
            observeDelayPolicy?.Invoke(delayPolicy, 418, typeof(IOException));

            // Cancel the function after 2 or 3 invocations
            int i = passResultPolicy ? 3 : 2;

            func.Invoking += c =>
            {
                if (c.Calls == i)
                    tokenSource.Cancel();
            };

            // Begin the invocation
            Assert.That.ThrowsException<OperationCanceledException>(() => invoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token), allowedDerivedTypes: true);

            // Validate the number of calls
            int r = i - 1;
            int x = passResultPolicy ? r / 2 : 0;
            int y = passResultPolicy ? r / 2 : r;
            Assert.AreEqual(i, func           .Calls);
            Assert.AreEqual(x, resultPolicy   .Calls);
            Assert.AreEqual(y, exceptionPolicy.Calls);
            Assert.AreEqual(r, delayPolicy    .Calls);
        }

        #endregion

        #region WithRetry<#= baseSuffix #>_Canceled_Delay

        private void WithRetry<#= baseSuffix #>_Canceled_Delay<TFunc, TDelayPolicy, TFuncProxy, TDelayPolicyProxy>(
            Func<Func<CancellationToken, int>, TFuncProxy> funcFactory,
            Func<TimeSpan, TDelayPolicyProxy> delayPolicyFactory,
            Func<TFunc, int, ResultPolicy<int>, ExceptionPolicy, TDelayPolicy, TFunc> withRetry,
            Func<TFunc<#= optionalComma #><#= typeArguments #>, CancellationToken, int> invoke,
            Action<TFuncProxy, TimeSpan> observeFunc,
            Action<TDelayPolicyProxy, int, Type> observeDelayPolicy,
            bool passResultPolicy)
            where TFunc             : Delegate
            where TDelayPolicy      : Delegate
            where TFuncProxy        : DelegateProxy<TFunc>
            where TDelayPolicyProxy : DelegateProxy<TDelayPolicy>
        {
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            // Create an "unsuccessful" user-defined func that continues to fail with transient exceptions until it's canceled
            Func<int> flakyFunc = passResultPolicy ? FlakyFunc.Create<int, IOException>(418) : () => throw new IOException();
            TFuncProxy func = funcFactory(t => flakyFunc());

            // Declare the various policy and event handler proxies
            FuncProxy<int, ResultKind> resultPolicy    = new FuncProxy<int, ResultKind>(r => r == 418 ? ResultKind.Transient : ResultKind.Successful);
            FuncProxy<Exception, bool> exceptionPolicy = new FuncProxy<Exception, bool>(ExceptionPolicies.Transient.Invoke);
            TDelayPolicyProxy delayPolicy = delayPolicyFactory(Constants.Delay);

            // Create the reliable function
            TFunc reliableFunc = withRetry(
                func.Proxy,
                Retries.Infinite,
                resultPolicy   .Invoke,
                exceptionPolicy.Invoke,
                delayPolicy.Proxy);

            // Define expectations
            resultPolicy   .Invoking += Expect.Result(418);
            exceptionPolicy.Invoking += Expect.Exception(typeof(IOException));

            observeFunc       ?.Invoke(func, Constants.MinDelay);
            observeDelayPolicy?.Invoke(delayPolicy, 418, typeof(IOException));

            // Cancel the delay after 1 or 2 invocations
            int r = passResultPolicy ? 2 : 1;

            delayPolicy.Invoking += c =>
            {
                if (c.Calls == r)
                    tokenSource.Cancel();
            };

            // Begin the invocation
            Assert.That.ThrowsException<OperationCanceledException>(() => invoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token), allowedDerivedTypes: true);

            // Validate the number of calls
            int x = passResultPolicy ? r / 2 : 0;
            int y = passResultPolicy ? r / 2 : r;
            Assert.AreEqual(r, func           .Calls);
            Assert.AreEqual(x, resultPolicy   .Calls);
            Assert.AreEqual(y, exceptionPolicy.Calls);
            Assert.AreEqual(r, delayPolicy    .Calls);
            
        }

        #endregion

    }
}
<#
        SaveOutput($"Func.Extensions.T{parameterCount + 1}.Test.cs");
    }
#>
<#= GetTemplateFileName() #> ran successfully
