<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".tt.out" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="$(MSBuildProjectDirectory)\TextTemplating\Include.t4" #><#
    // Assume a boolean variable called "async" has been previously defined!
    string optionalAsync = async ? "Async" : string.Empty;

    for (int parameterCount = 0; parameterCount <= MaxDelegateParameters; parameterCount++)
    {
        string optionalComma      = parameterCount > 0 ? ", " : string.Empty;
        string arguments          = GetArguments     (          parameterCount);
        string parameters         = GetParameters    (typeArgs, parameterCount);
        string argumentValues     = GetArgumentValues(          parameterCount);
        string inputTypeArguments = GetTypeArguments (          parameterCount);
        string typeArguments      = GetTypeArguments (          parameterCount, outputType: "string");

        string inputFuncTypeArguments      = Enclose(GetTypeArguments(parameterCount, async, interruptable: false, outputType: "string"), BracketType.AngleBrackets);
        string tokenInputFuncTypeArguments = Enclose(GetTypeArguments(parameterCount, async, interruptable: true , outputType: "string"), BracketType.AngleBrackets);
#>
// Generated from <#= GetTemplateFileName() #>
using System;
using System.IO;
using System.Threading;
<#
        if (async)
        {
#>
using System.Threading.Tasks;
<#
        }
#>
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Sweetener.Reliability.Test
{
    [TestClass]
    public sealed class Reliable<#= optionalAsync #>Func<#= parameterCount > 0 ? parameterCount.ToString() : string.Empty #>Test : ReliableDelegateTest<string>
    {
        private static readonly Func<Reliable<#= optionalAsync #>Func<<#= typeArguments #>>, Func<#= tokenInputFuncTypeArguments #>> s_getFunc = DynamicGetter.ForField<Reliable<#= optionalAsync #>Func<<#= typeArguments #>>, Func<#= tokenInputFuncTypeArguments #>>("_func");

        [TestMethod]
        public void Ctor_DelayHandler()
            => Ctor_DelayHandler((f, m, e, d) => new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(f, m, e, d));

        [TestMethod]
        public void Ctor_ComplexDelayHandler()
            => Ctor_ComplexDelayHandler((f, m, e, d) => new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(f, m, e, d));

        [TestMethod]
        public void Ctor_ResultHandler_DelayHandler()
            => Ctor_ResultHandler_DelayHandler((f, m, r, e, d) => new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(f, m, r, e, d));

        [TestMethod]
        public void Ctor_ResultHandler_ComplexDelayHandler()
            => Ctor_ResultHandler_ComplexDelayHandler((f, m, r, e, d) => new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(f, m, r, e, d));

        [TestMethod]
        public void Ctor_Interruptable_DelayHandler()
            => Ctor_Interruptable_DelayHandler((f, m, e, d) => new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(f, m, e, d));

        [TestMethod]
        public void Ctor_Interruptable_ComplexDelayHandler()
            => Ctor_Interruptable_ComplexDelayHandler((f, m, e, d) => new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(f, m, e, d));

        [TestMethod]
        public void Ctor_Interruptable_ResultHandler_DelayHandler()
            => Ctor_Interruptable_ResultHandler_DelayHandler((f, m, r, e, d) => new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(f, m, r, e, d));

        [TestMethod]
        public void Ctor_Interruptable_ResultHandler_ComplexDelayHandler()
            => Ctor_Interruptable_ResultHandler_ComplexDelayHandler((f, m, r, e, d) => new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(f, m, r, e, d));

        [TestMethod]
        public void Create_DelayHandler()
            => Ctor_DelayHandler((f, m, e, d) => Reliable<#= optionalAsync #>Func.Create(f, m, e, d));

        [TestMethod]
        public void Create_ComplexDelayHandler()
            => Ctor_ComplexDelayHandler((f, m, e, d) => Reliable<#= optionalAsync #>Func.Create(f, m, e, d));

        [TestMethod]
        public void Create_ResultHandler_DelayHandler()
            => Ctor_ResultHandler_DelayHandler((f, m, r, e, d) => Reliable<#= optionalAsync #>Func.Create(f, m, r, e, d));

        [TestMethod]
        public void Create_ResultHandler_ComplexDelayHandler()
            => Ctor_ResultHandler_ComplexDelayHandler((f, m, r, e, d) => Reliable<#= optionalAsync #>Func.Create(f, m, r, e, d));

        [TestMethod]
        public void Create_Interruptable_DelayHandler()
            => Ctor_Interruptable_DelayHandler((f, m, e, d) => Reliable<#= optionalAsync #>Func.Create(f, m, e, d));

        [TestMethod]
        public void Create_Interruptable_ComplexDelayHandler()
            => Ctor_Interruptable_ComplexDelayHandler((f, m, e, d) => Reliable<#= optionalAsync #>Func.Create(f, m, e, d));

        [TestMethod]
        public void Create_Interruptable_ResultHandler_DelayHandler()
            => Ctor_Interruptable_ResultHandler_DelayHandler((f, m, r, e, d) => Reliable<#= optionalAsync #>Func.Create(f, m, r, e, d));

        [TestMethod]
        public void Create_Interruptable_ResultHandler_ComplexDelayHandler()
            => Ctor_Interruptable_ResultHandler_ComplexDelayHandler((f, m, r, e, d) => Reliable<#= optionalAsync #>Func.Create(f, m, r, e, d));

<#
        if (!async)
        {
#>
        [TestMethod]
        public void Invoke()
            => Invoke(passToken: false);

        [TestMethod]
        public void Invoke_CancellationToken()
            => Invoke(passToken: true);

<#
        }
#>
        [TestMethod]
        public void InvokeAsync()
            => InvokeAsync(passToken: false);

        [TestMethod]
        public void InvokeAsync_CancellationToken()
            => InvokeAsync(passToken: true);

<#
        if (!async)
        {
#>
        [TestMethod]
        public void TryInvoke()
            => TryInvoke(passToken: false);

        [TestMethod]
        public void TryInvoke_CancellationToken()
            => TryInvoke(passToken: true);

<#
        }
#>
        #region Ctor

<#
        foreach (bool interruptable in new bool[] { false, true })
        {
            string ctorInputTypeArguments = interruptable  ? tokenInputFuncTypeArguments : inputFuncTypeArguments;
            string optionalFuncInvoke     = !interruptable ? ".Invoke"                   : string.Empty;
            string optionalProxy          = !interruptable ? "Proxy"                     : string.Empty;

            foreach (bool passResultHandler in new bool[] { false, true })
            {
                string optionalResultHandler     = passResultHandler ? ", resultHandler" : string.Empty;
                string optionalResultHandlerType = passResultHandler ? ", ResultHandler<string>" : string.Empty;

                foreach (bool useComplexHandler in new bool[] { false, true })
                {
                    string delayHandlerType      = useComplexHandler  ? "ComplexDelayHandler<string>" : "DelayHandler";
                    string optionalHandlerInvoke = !useComplexHandler ? ".Invoke"            : string.Empty;
                    string testName             = "Ctor" + (interruptable ? "_Interruptable" : string.Empty) + (passResultHandler ? "_ResultHandler" : string.Empty) + "_" + (useComplexHandler  ? "ComplexDelayHandler" : "DelayHandler");
#>
        private void <#= testName #>(Func<Func<#= ctorInputTypeArguments #>, int<#= optionalResultHandlerType #>, ExceptionHandler, <#= delayHandlerType #>, Reliable<#= optionalAsync #>Func<<#= typeArguments #>>> factory)
        {
            Func<#= optionalProxy #><#= ctorInputTypeArguments #> func = <#= interruptable ? GetExpressionDelegate(parameterCount, "\"Hello World\"", async, interruptable: true) : $"new Func{optionalProxy}{ctorInputTypeArguments}()" #>;
<#
                    if (passResultHandler)
                    {
#>
            ResultHandler<string> resultHandler = r => r == "Successful Value" ? ResultKind.Successful : ResultKind.Fatal;
<#
                    }
#>
            ExceptionHandler exceptionHandler = ExceptionPolicy.Fatal;
<#
                    if (useComplexHandler)
                    {
#>
            ComplexDelayHandler<string> delayHandler = (i, r, e) => TimeSpan.FromHours(1);
<#
                    }
                    else
                    {
#>
            FuncProxy<int, TimeSpan> delayHandler = new FuncProxy<int, TimeSpan>(i => Constants.Delay);
<#
                    }
                    if (passResultHandler)
                    {
#>

            Assert.ThrowsException<ArgumentNullException      >(() => factory(null, Retries.Infinite, resultHandler, exceptionHandler, delayHandler.Invoke));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => factory(func<#= optionalFuncInvoke #>, -2              , resultHandler, exceptionHandler, delayHandler<#= optionalHandlerInvoke #>));
            Assert.ThrowsException<ArgumentNullException      >(() => factory(func<#= optionalFuncInvoke #>, Retries.Infinite, null         , exceptionHandler, delayHandler<#= optionalHandlerInvoke #>));
            Assert.ThrowsException<ArgumentNullException      >(() => factory(func<#= optionalFuncInvoke #>, Retries.Infinite, resultHandler, null            , delayHandler<#= optionalHandlerInvoke #>));
            Assert.ThrowsException<ArgumentNullException      >(() => factory(func<#= optionalFuncInvoke #>, Retries.Infinite, resultHandler, exceptionHandler, null));
<#
                    }
                    else
                    {
#>

            Assert.ThrowsException<ArgumentNullException      >(() => factory(null, Retries.Infinite, exceptionHandler, delayHandler<#= optionalHandlerInvoke #>));
            Assert.ThrowsException<ArgumentOutOfRangeException>(() => factory(func<#= optionalFuncInvoke #>, -2              , exceptionHandler, delayHandler<#= optionalHandlerInvoke #>));
            Assert.ThrowsException<ArgumentNullException      >(() => factory(func<#= optionalFuncInvoke #>, Retries.Infinite, null            , delayHandler<#= optionalHandlerInvoke #>));
            Assert.ThrowsException<ArgumentNullException      >(() => factory(func<#= optionalFuncInvoke #>, Retries.Infinite, exceptionHandler, null));
<#
                    }
#>

            // Create a Reliable<#= optionalAsync #>Func and validate
            Reliable<#= optionalAsync #>Func<<#= typeArguments #>> actual = factory(func<#= optionalFuncInvoke #>, 37<#= optionalResultHandler #>, exceptionHandler, delayHandler<#= optionalHandlerInvoke #>);

            Ctor(actual, 37<#= optionalResultHandler #>, exceptionHandler, delayHandler);
            CtorFunc(actual, func);
        }

<#
                }
            }
        }
#>
        private void CtorFunc(Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc, FuncProxy<#= inputFuncTypeArguments #> expected)
            => CtorFunc(reliableFunc, actual =>
            {
<#
        if (parameterCount > 0)
        {
#>
                expected.Invoking += Expect.Arguments<<#= inputTypeArguments #>>(Arguments.Validate);

<#
        }
#>
                Assert.AreEqual(0, expected.Calls);
                actual(<#= argumentValues #><#= optionalComma #>default);
                Assert.AreEqual(1, expected.Calls);
            });

        private void CtorFunc(Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc, Func<#= tokenInputFuncTypeArguments #> expected)
            => CtorFunc(reliableFunc, actual => Assert.AreSame(expected, actual));

        private void CtorFunc(Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc, Action<Func<#= tokenInputFuncTypeArguments #>> validateFunc)
            => validateFunc(s_getFunc(reliableFunc));

        #endregion

<#
        if (!async)
        {
#>
        #region Invoke

        private void Invoke(bool passToken)
        {
            Func<ReliableFunc<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, string> invoke;
            if (passToken)
                invoke = (r<#= optionalComma #><#= arguments #>, t) => r.Invoke(<#= arguments #><#= optionalComma #>t);
            else
                invoke = (r<#= optionalComma #><#= arguments #>, t) => r.Invoke(<#= arguments #>);

            // Callers may optionally include event handlers
            foreach (bool addEventHandlers in new bool[] { false, true })
            {
                // Success
                Invoke_Success                ((f<#= optionalComma #><#= arguments #>, t, r) => Assert.AreEqual(r, invoke(f<#=optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_EventualSuccess        ((f<#= optionalComma #><#= arguments #>, t, r) => Assert.AreEqual(r, invoke(f<#=optionalComma #><#= arguments #>, t)), addEventHandlers);

                // Failure (Result)
                Invoke_Failure_Result         ((f<#= optionalComma #><#= arguments #>, t, r) => Assert.AreEqual(r, invoke(f<#=optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_EventualFailure_Result ((f<#= optionalComma #><#= arguments #>, t, r) => Assert.AreEqual(r, invoke(f<#=optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_RetriesExhausted_Result((f<#= optionalComma #><#= arguments #>, t, r) => Assert.AreEqual(r, invoke(f<#=optionalComma #><#= arguments #>, t)), addEventHandlers);

                // Failure (Exception)
                Invoke_Failure_Exception         ((f<#= optionalComma #><#= arguments #>, t, e) => Assert.That.ThrowsException(() => invoke(f<#=optionalComma #><#= arguments #>, t), e), addEventHandlers);
                Invoke_EventualFailure_Exception ((f<#= optionalComma #><#= arguments #>, t, e) => Assert.That.ThrowsException(() => invoke(f<#=optionalComma #><#= arguments #>, t), e), addEventHandlers);
                Invoke_RetriesExhausted_Exception((f<#= optionalComma #><#= arguments #>, t, e) => Assert.That.ThrowsException(() => invoke(f<#=optionalComma #><#= arguments #>, t), e), addEventHandlers);

                if (passToken)
                {
                    Invoke_Canceled_Func ((f<#= optionalComma #><#= arguments #>, t) => f.Invoke(<#= arguments #><#= optionalComma #>t), addEventHandlers);
                    Invoke_Canceled_Delay((f<#= optionalComma #><#= arguments #>, t) => f.Invoke(<#= arguments #><#= optionalComma #>t), addEventHandlers);
                }
            }
        }

        #endregion

<#
        }
#>
        #region InvokeAsync

        private void InvokeAsync(bool passToken)
        {
            Func<Reliable<#= optionalAsync #>Func<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, string> invoke;
            if (passToken)
                invoke = (r<#= optionalComma #><#= arguments #>, t) => r.InvokeAsync(<#= arguments #><#= optionalComma #>t).Result;
            else
                invoke = (r<#= optionalComma #><#= arguments #>, t) => r.InvokeAsync(<#= arguments #>).Result;

<#
        if (async)
        {
#>
            // Test a function that returns a null Task
            ReliableAsyncFunc<<#= typeArguments #>> badFunc = new ReliableAsyncFunc<<#= typeArguments #>>((<#= arguments #>) => null, Retries.Infinite, ExceptionPolicy.Transient, DelayPolicy.None);
            Assert.That.ThrowsException<InvalidOperationException>(() => invoke(badFunc<#= optionalComma #><#= argumentValues #>, CancellationToken.None));

<#
        }
#>
            // Callers may optionally include event handlers
            foreach (bool addEventHandlers in new bool[] { false, true })
            {
                // Success
                Invoke_Success                ((f<#= optionalComma #><#= arguments #>, t, r) => Assert.AreEqual(r, invoke(f<#=optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_EventualSuccess        ((f<#= optionalComma #><#= arguments #>, t, r) => Assert.AreEqual(r, invoke(f<#=optionalComma #><#= arguments #>, t)), addEventHandlers);

                // Failure (Result)
                Invoke_Failure_Result         ((f<#= optionalComma #><#= arguments #>, t, r) => Assert.AreEqual(r, invoke(f<#=optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_EventualFailure_Result ((f<#= optionalComma #><#= arguments #>, t, r) => Assert.AreEqual(r, invoke(f<#=optionalComma #><#= arguments #>, t)), addEventHandlers);
                Invoke_RetriesExhausted_Result((f<#= optionalComma #><#= arguments #>, t, r) => Assert.AreEqual(r, invoke(f<#=optionalComma #><#= arguments #>, t)), addEventHandlers);

                // Failure (Exception)
                Invoke_Failure_Exception         ((f<#= optionalComma #><#= arguments #>, t, e) => Assert.That.ThrowsException(() => invoke(f<#=optionalComma #><#= arguments #>, t), e), addEventHandlers);
                Invoke_EventualFailure_Exception ((f<#= optionalComma #><#= arguments #>, t, e) => Assert.That.ThrowsException(() => invoke(f<#=optionalComma #><#= arguments #>, t), e), addEventHandlers);
                Invoke_RetriesExhausted_Exception((f<#= optionalComma #><#= arguments #>, t, e) => Assert.That.ThrowsException(() => invoke(f<#=optionalComma #><#= arguments #>, t), e), addEventHandlers);

                if (passToken)
                {
<#
        if (async)
        {
#>
                    Invoke_Canceled_Func ((f<#= optionalComma #><#= arguments #>, t) => f.InvokeAsync(<#= arguments #><#= optionalComma #>t).Wait(), addEventHandlers, useSynchronousFunc: false);
                    Invoke_Canceled_Func ((f<#= optionalComma #><#= arguments #>, t) => f.InvokeAsync(<#= arguments #><#= optionalComma #>t).Wait(), addEventHandlers, useSynchronousFunc: true );
<#
        }
        else
        {
#>
                    Invoke_Canceled_Func ((f<#= optionalComma #><#= arguments #>, t) => f.InvokeAsync(<#= arguments #><#= optionalComma #>t).Wait(), addEventHandlers);
<#
        }
#>
                    Invoke_Canceled_Delay((f<#= optionalComma #><#= arguments #>, t) => f.InvokeAsync(<#= arguments #><#= optionalComma #>t).Wait(), addEventHandlers);
                }
            }
        }

        #endregion

<#
        if (!async)
        {
#>
        #region TryInvoke

        private void TryInvoke(bool passToken)
        {
            TryFunc<ReliableFunc<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, string> tryInvoke;
            if (passToken)
                tryInvoke = TryInvokeFuncWithToken;
            else
                tryInvoke = TryInvokeFunc;

            Action<ReliableFunc<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, string> assertSuccess =
                (f<#= optionalComma #><#= arguments #>, t, r) =>
                {
                    Assert.IsTrue(tryInvoke(f<#=optionalComma #><#= arguments #>, t, out string actual));
                    Assert.AreEqual(r, actual);
                };

            Action<ReliableFunc<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, string> assertResultFailure =
                (f<#= optionalComma #><#= arguments #>, t, r) =>
                {
                    // TryInvoke returns the default value instead of the failed value 'r'
                    Assert.IsFalse(tryInvoke(f<#=optionalComma #><#= arguments #>, t, out string actual));
                    Assert.AreEqual(default, actual);
                };

            Action<ReliableFunc<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, Type> assertExceptionFailure =
                (f<#= optionalComma #><#= arguments #>, t, e) =>
                {
                    // TryInvoke returns false instead of throwing the provided exception 'e'
                    Assert.IsFalse(tryInvoke(f<#=optionalComma #><#= arguments #>, t, out string actual));
                    Assert.AreEqual(default, actual);
                };

            foreach (bool addEventHandlers in new bool[] { false, true })
            {
                // Success
                Invoke_Success                (assertSuccess, addEventHandlers);
                Invoke_EventualSuccess        (assertSuccess, addEventHandlers);

                // Failure (Result)
                Invoke_Failure_Result         (assertResultFailure, addEventHandlers);
                Invoke_EventualFailure_Result (assertResultFailure, addEventHandlers);
                Invoke_RetriesExhausted_Result(assertResultFailure, addEventHandlers);

                // Failure (Exception)
                Invoke_Failure_Exception         (assertExceptionFailure, addEventHandlers);
                Invoke_EventualFailure_Exception (assertExceptionFailure, addEventHandlers);
                Invoke_RetriesExhausted_Exception(assertExceptionFailure, addEventHandlers);

                if (passToken)
                {
                    Invoke_Canceled_Func ((f<#= optionalComma #><#= arguments #>, t) => f.TryInvoke(<#= arguments #><#= optionalComma #>t, out string _), addEventHandlers);
                    Invoke_Canceled_Delay((f<#= optionalComma #><#= arguments #>, t) => f.TryInvoke(<#= arguments #><#= optionalComma #>t, out string _), addEventHandlers);
                }
            }

            bool TryInvokeFunc(ReliableFunc<<#= typeArguments #>> reliableFunc<#= optionalComma #><#= parameters #>, CancellationToken token, out string result)
                => reliableFunc.TryInvoke(<#= arguments #><#= optionalComma #>out result);

            bool TryInvokeFuncWithToken(ReliableFunc<<#= typeArguments #>> reliableFunc<#= optionalComma #><#= parameters #>, CancellationToken token, out string result)
                => reliableFunc.TryInvoke(<#= arguments #><#= optionalComma #>token, out result);
        }

        #endregion

<#
        }
#>
        #region Invoke_Success

        private void Invoke_Success(Action<Reliable<#= optionalAsync #>Func<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, string> assertInvoke, bool addEventHandlers)
        {
            // Create a "successful" user-defined function
            FuncProxy<#= inputFuncTypeArguments #> func = new FuncProxy<#= inputFuncTypeArguments #>(<#= GetExpressionDelegate(parameterCount, "\"Success\"", async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<string, ResultKind>               resultHandler    = new FuncProxy<string, ResultKind>(r => r == "Success" ? ResultKind.Successful : ResultKind.Fatal);
            FuncProxy<Exception, bool>                  exceptionHandler = new FuncProxy<Exception, bool>();
            FuncProxy<int, string, Exception, TimeSpan> delayHandler     = new FuncProxy<int, string, Exception, TimeSpan>();

            ActionProxy<int, string, Exception> retryHandler     = new ActionProxy<int, string, Exception>();
            ActionProxy<string, Exception>      failedHandler    = new ActionProxy<string, Exception>();
            ActionProxy<string, Exception>      exhaustedHandler = new ActionProxy<string, Exception>();

            // Create Reliable<#= optionalAsync #>Func
            Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc = new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(
                func.Invoke,
                Retries.Infinite,
                resultHandler   .Invoke,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliableFunc.Retrying         += retryHandler    .Invoke;
                reliableFunc.Failed           += failedHandler   .Invoke;
                reliableFunc.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            func            .Invoking += Expect.Arguments<<#= inputTypeArguments #>>(Arguments.Validate);
<#
        }
#>
            resultHandler   .Invoking += Expect.Result("Success");
            exceptionHandler.Invoking += Expect.Nothing<Exception>();
            delayHandler    .Invoking += Expect.Nothing<int, string, Exception>();
            retryHandler    .Invoking += Expect.Nothing<int, string, Exception>();
            failedHandler   .Invoking += Expect.Nothing<string, Exception>();
            exhaustedHandler.Invoking += Expect.Nothing<string, Exception>();

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token, "Success");

            // Validate the number of calls
            Assert.AreEqual(1, func            .Calls);
            Assert.AreEqual(1, resultHandler   .Calls);
            Assert.AreEqual(0, exceptionHandler.Calls);
            Assert.AreEqual(0, delayHandler    .Calls);
            Assert.AreEqual(0, retryHandler    .Calls);
            Assert.AreEqual(0, failedHandler   .Calls);
            Assert.AreEqual(0, exhaustedHandler.Calls);
        }

        #endregion

        #region Invoke_Failure_Result

        private void Invoke_Failure_Result(Action<Reliable<#= optionalAsync #>Func<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, string> assertInvoke, bool addEventHandlers)
        {
            // Create an "unsuccessful" user-defined function that returns a fatal result
            FuncProxy<#= inputFuncTypeArguments #> func = new FuncProxy<#= inputFuncTypeArguments #>(<#= GetExpressionDelegate(parameterCount, "\"Failure\"", async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<string, ResultKind>               resultHandler    = new FuncProxy<string, ResultKind>(r => r == "Failure" ? ResultKind.Fatal : ResultKind.Successful);
            FuncProxy<Exception, bool>                  exceptionHandler = new FuncProxy<Exception, bool>();
            FuncProxy<int, string, Exception, TimeSpan> delayHandler     = new FuncProxy<int, string, Exception, TimeSpan>();

            ActionProxy<int, string, Exception> retryHandler     = new ActionProxy<int, string, Exception>();
            ActionProxy<string, Exception>      failedHandler    = new ActionProxy<string, Exception>();
            ActionProxy<string, Exception>      exhaustedHandler = new ActionProxy<string, Exception>();

            // Create Reliable<#= optionalAsync #>Func
            Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc = new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(
                func.Invoke,
                Retries.Infinite,
                resultHandler   .Invoke,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliableFunc.Retrying         += retryHandler    .Invoke;
                reliableFunc.Failed           += failedHandler   .Invoke;
                reliableFunc.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            func            .Invoking += Expect.Arguments<<#= inputTypeArguments #>>(Arguments.Validate);
<#
        }
#>
            resultHandler   .Invoking += Expect.Result("Failure");
            exceptionHandler.Invoking += Expect.Nothing<Exception>();
            delayHandler    .Invoking += Expect.Nothing<int, string, Exception>();
            retryHandler    .Invoking += Expect.Nothing<int, string, Exception>();
            failedHandler   .Invoking += Expect.OnlyResult("Failure");
            exhaustedHandler.Invoking += Expect.Nothing<string, Exception>();

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token, "Failure");

            // Validate the number of calls
            Assert.AreEqual(1, func            .Calls);
            Assert.AreEqual(1, resultHandler   .Calls);
            Assert.AreEqual(0, exceptionHandler.Calls);
            Assert.AreEqual(0, delayHandler    .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(0, retryHandler    .Calls);
                Assert.AreEqual(1, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_Failure_Exception

        private void Invoke_Failure_Exception(Action<Reliable<#= optionalAsync #>Func<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, Type> assertInvoke, bool addEventHandlers)
        {
            // Create an "unsuccessful" user-defined function that throws a fatal exception
            FuncProxy<#= inputFuncTypeArguments #> func = new FuncProxy<#= inputFuncTypeArguments #>(<#= GetThrowDelegate<OutOfMemoryException>(parameterCount, async, outputType: "string") #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<string, ResultKind>               resultHandler    = new FuncProxy<string, ResultKind>();
            FuncProxy<Exception, bool>                  exceptionHandler = new FuncProxy<Exception, bool>(ExceptionPolicy.Fail<OutOfMemoryException>().Invoke);
            FuncProxy<int, string, Exception, TimeSpan> delayHandler     = new FuncProxy<int, string, Exception, TimeSpan>();

            ActionProxy<int, string, Exception> retryHandler     = new ActionProxy<int, string, Exception>();
            ActionProxy<string, Exception>      failedHandler    = new ActionProxy<string, Exception>();
            ActionProxy<string, Exception>      exhaustedHandler = new ActionProxy<string, Exception>();

            // Create Reliable<#= optionalAsync #>Func
            Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc = new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(
                func.Invoke,
                Retries.Infinite,
                resultHandler   .Invoke,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliableFunc.Retrying         += retryHandler    .Invoke;
                reliableFunc.Failed           += failedHandler   .Invoke;
                reliableFunc.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            func            .Invoking += Expect.Arguments<<#= inputTypeArguments #>>(Arguments.Validate);
<#
        }
#>
            resultHandler   .Invoking += Expect.Nothing<string>();
            exceptionHandler.Invoking += Expect.Exception(typeof(OutOfMemoryException));
            delayHandler    .Invoking += Expect.Nothing<int, string, Exception>();
            retryHandler    .Invoking += Expect.Nothing<int, string, Exception>();
            failedHandler   .Invoking += Expect.OnlyException<string>(typeof(OutOfMemoryException));
            exhaustedHandler.Invoking += Expect.Nothing<string, Exception>();

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token, typeof(OutOfMemoryException));

            // Validate the number of calls
            Assert.AreEqual(1, func             .Calls);
            Assert.AreEqual(0, resultHandler    .Calls);
            Assert.AreEqual(1, exceptionHandler .Calls);
            Assert.AreEqual(0, delayHandler     .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(0, retryHandler    .Calls);
                Assert.AreEqual(1, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_EventualSuccess

        private void Invoke_EventualSuccess(Action<Reliable<#= optionalAsync #>Func<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, string> assertInvoke, bool addEventHandlers)
        {
            // Create a user-defined function that eventually succeeds after a transient result and exception
            Func<string> flakyFunc = FlakyFunc.Create<string, IOException>("Retry", "Success", 2);
            FuncProxy<#= inputFuncTypeArguments #> func = new FuncProxy<#= inputFuncTypeArguments #>(<#= GetExpressionDelegate(parameterCount, "flakyFunc()", async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<string, ResultKind>               resultHandler    = new FuncProxy<string, ResultKind>(r =>
                r switch
                {
                    "Retry"   => ResultKind.Transient,
                    "Success" => ResultKind.Successful,
                    _         => ResultKind.Fatal,
                });
            FuncProxy<Exception, bool>                  exceptionHandler = new FuncProxy<Exception, bool>(ExceptionPolicy.Retry<IOException>().Invoke);
            FuncProxy<int, string, Exception, TimeSpan> delayHandler     = new FuncProxy<int, string, Exception, TimeSpan>((i, r, e) => Constants.Delay);

            ActionProxy<int, string, Exception> retryHandler     = new ActionProxy<int, string, Exception>();
            ActionProxy<string, Exception>      failedHandler    = new ActionProxy<string, Exception>();
            ActionProxy<string, Exception>      exhaustedHandler = new ActionProxy<string, Exception>();

            // Create Reliable<#= optionalAsync #>Func
            Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc = new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(
                func.Invoke,
                Retries.Infinite,
                resultHandler   .Invoke,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliableFunc.Retrying         += retryHandler    .Invoke;
                reliableFunc.Failed           += failedHandler   .Invoke;
                reliableFunc.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            func            .Invoking += Expect.Arguments<<#= inputTypeArguments #>>(Arguments.Validate);
<#
        }
        else
        {
#>
            func            .Invoking += Expect.AfterDelay(Constants.MinDelay);
<#
        }
#>
            resultHandler   .Invoking += Expect.Results("Retry", "Success", 1);
            exceptionHandler.Invoking += Expect.Exception(typeof(IOException));
            delayHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            retryHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            failedHandler   .Invoking += Expect.Nothing<string, Exception>();
            exhaustedHandler.Invoking += Expect.Nothing<string, Exception>();

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token, "Success");

            // Validate the number of calls
            Assert.AreEqual(3, func             .Calls);
            Assert.AreEqual(2, resultHandler    .Calls);
            Assert.AreEqual(1, exceptionHandler .Calls);
            Assert.AreEqual(2, delayHandler     .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(2, retryHandler    .Calls);
                Assert.AreEqual(0, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_EventualFailure_Result

        private void Invoke_EventualFailure_Result(Action<Reliable<#= optionalAsync #>Func<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, string> assertInvoke, bool addEventHandlers)
        {
            // Create a user-defined function that eventually fails after a transient result and exception
            Func<string> flakyFunc = FlakyFunc.Create<string, IOException>("Retry", "Failure", 2);
            FuncProxy<#= inputFuncTypeArguments #> func = new FuncProxy<#= inputFuncTypeArguments #>(<#= GetExpressionDelegate(parameterCount, "flakyFunc()", async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<string, ResultKind>               resultHandler    = new FuncProxy<string, ResultKind>(r =>
                r switch
                {
                    "Retry"   => ResultKind.Transient,
                    "Failure" => ResultKind.Fatal,
                    _         => ResultKind.Successful,
                });
            FuncProxy<Exception, bool>                  exceptionHandler = new FuncProxy<Exception, bool>(ExceptionPolicy.Retry<IOException>().Invoke);
            FuncProxy<int, string, Exception, TimeSpan> delayHandler     = new FuncProxy<int, string, Exception, TimeSpan>((i, r, e) => Constants.Delay);

            ActionProxy<int, string, Exception> retryHandler     = new ActionProxy<int, string, Exception>();
            ActionProxy<string, Exception>      failedHandler    = new ActionProxy<string, Exception>();
            ActionProxy<string, Exception>      exhaustedHandler = new ActionProxy<string, Exception>();

            // Create Reliable<#= optionalAsync #>Func
            Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc = new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(
                func.Invoke,
                Retries.Infinite,
                resultHandler   .Invoke,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliableFunc.Retrying         += retryHandler    .Invoke;
                reliableFunc.Failed           += failedHandler   .Invoke;
                reliableFunc.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            func            .Invoking += Expect.ArgumentsAfterDelay<<#= inputTypeArguments #>>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            func            .Invoking += Expect.AfterDelay(Constants.MinDelay);
<#
        }
#>
            resultHandler   .Invoking += Expect.Results("Retry", "Failure", 1);
            exceptionHandler.Invoking += Expect.Exception(typeof(IOException));
            delayHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            retryHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            failedHandler   .Invoking += Expect.OnlyResult("Failure");
            exhaustedHandler.Invoking += Expect.Nothing<string, Exception>();

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token, "Failure");

            // Validate the number of calls
            Assert.AreEqual(3, func             .Calls);
            Assert.AreEqual(2, resultHandler    .Calls);
            Assert.AreEqual(1, exceptionHandler .Calls);
            Assert.AreEqual(2, delayHandler     .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(2, retryHandler    .Calls);
                Assert.AreEqual(1, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_EventualFailure_Exception

        private void Invoke_EventualFailure_Exception(Action<Reliable<#= optionalAsync #>Func<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, Type> assertInvoke, bool addEventHandlers)
        {
            // Create a user-defined function that eventually fails after a transient result and exception
            Func<string> flakyFunc = FlakyFunc.Create<string, IOException, OutOfMemoryException>("Retry", 2);
            FuncProxy<#= inputFuncTypeArguments #> func = new FuncProxy<#= inputFuncTypeArguments #>(<#= GetExpressionDelegate(parameterCount, "flakyFunc()", async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<string, ResultKind>               resultHandler    = new FuncProxy<string, ResultKind>(r => r == "Retry" ? ResultKind.Transient : ResultKind.Successful);
            FuncProxy<Exception, bool>                  exceptionHandler = new FuncProxy<Exception, bool>(ExceptionPolicy.Retry<IOException>().Invoke);
            FuncProxy<int, string, Exception, TimeSpan> delayHandler     = new FuncProxy<int, string, Exception, TimeSpan>((i, r, e) => Constants.Delay);

            ActionProxy<int, string, Exception> retryHandler     = new ActionProxy<int, string, Exception>();
            ActionProxy<string, Exception>      failedHandler    = new ActionProxy<string, Exception>();
            ActionProxy<string, Exception>      exhaustedHandler = new ActionProxy<string, Exception>();

            // Create Reliable<#= optionalAsync #>Func
            Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc = new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(
                func.Invoke,
                Retries.Infinite,
                resultHandler   .Invoke,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliableFunc.Retrying         += retryHandler    .Invoke;
                reliableFunc.Failed           += failedHandler   .Invoke;
                reliableFunc.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            func            .Invoking += Expect.ArgumentsAfterDelay<<#= inputTypeArguments #>>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            func            .Invoking += Expect.AfterDelay(Constants.MinDelay);
<#
        }
#>
            resultHandler   .Invoking += Expect.Result("Retry");
            exceptionHandler.Invoking += Expect.Exceptions(typeof(IOException), typeof(OutOfMemoryException), 1);
            delayHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            retryHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            failedHandler   .Invoking += Expect.OnlyException<string>(typeof(OutOfMemoryException));
            exhaustedHandler.Invoking += Expect.Nothing<string, Exception>();

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token, typeof(OutOfMemoryException));

            // Validate the number of calls
            Assert.AreEqual(3, func             .Calls);
            Assert.AreEqual(1, resultHandler    .Calls);
            Assert.AreEqual(2, exceptionHandler .Calls);
            Assert.AreEqual(2, delayHandler     .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(2, retryHandler    .Calls);
                Assert.AreEqual(1, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_RetriesExhausted_Result

        private void Invoke_RetriesExhausted_Result(Action<Reliable<#= optionalAsync #>Func<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, string> assertInvoke, bool addEventHandlers)
        {
            // Create a user-defined function that eventually exhausts the maximum number of retries after transient results and exceptions
            Func<string> flakyFunc = FlakyFunc.Create<string, IOException>("Retry");
            FuncProxy<#= inputFuncTypeArguments #> func = new FuncProxy<#= inputFuncTypeArguments #>(<#= GetExpressionDelegate(parameterCount, "flakyFunc()", async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<string, ResultKind>               resultHandler    = new FuncProxy<string, ResultKind>(r => r == "Retry" ? ResultKind.Transient : ResultKind.Successful);
            FuncProxy<Exception, bool>                  exceptionHandler = new FuncProxy<Exception, bool>(ExceptionPolicy.Retry<IOException>().Invoke);
            FuncProxy<int, string, Exception, TimeSpan> delayHandler     = new FuncProxy<int, string, Exception, TimeSpan>((i, r, e) => Constants.Delay);

            ActionProxy<int, string, Exception> retryHandler     = new ActionProxy<int, string, Exception>();
            ActionProxy<string, Exception>      failedHandler    = new ActionProxy<string, Exception>();
            ActionProxy<string, Exception>      exhaustedHandler = new ActionProxy<string, Exception>();

            // Create Reliable<#= optionalAsync #>Func
            Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc = new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(
                func.Invoke,
                3, // Exception, Result, Exception, Result, ...
                resultHandler   .Invoke,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliableFunc.Retrying         += retryHandler    .Invoke;
                reliableFunc.Failed           += failedHandler   .Invoke;
                reliableFunc.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            func            .Invoking += Expect.ArgumentsAfterDelay<<#= inputTypeArguments #>>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            func            .Invoking += Expect.AfterDelay(Constants.MinDelay);
<#
        }
#>
            resultHandler   .Invoking += Expect.Result("Retry");
            exceptionHandler.Invoking += Expect.Exception(typeof(IOException));
            delayHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            retryHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            failedHandler   .Invoking += Expect.Nothing<string, Exception>();
            exhaustedHandler.Invoking += Expect.OnlyResult("Retry");

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token, "Retry");

            // Validate the number of calls
            Assert.AreEqual(4, func             .Calls);
            Assert.AreEqual(2, resultHandler    .Calls);
            Assert.AreEqual(2, exceptionHandler .Calls);
            Assert.AreEqual(3, delayHandler     .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(3, retryHandler    .Calls);
                Assert.AreEqual(0, failedHandler   .Calls);
                Assert.AreEqual(1, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_RetriesExhausted_Exception

        private void Invoke_RetriesExhausted_Exception(Action<Reliable<#= optionalAsync #>Func<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken, Type> assertInvoke, bool addEventHandlers)
        {
            // Create a user-defined function that eventually exhausts the maximum number of retries after transient results and exceptions
            Func<string> flakyFunc = FlakyFunc.Create<string, IOException>("Retry");
            FuncProxy<#= inputFuncTypeArguments #> func = new FuncProxy<#= inputFuncTypeArguments #>(<#= GetExpressionDelegate(parameterCount, "flakyFunc()", async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<string, ResultKind>               resultHandler    = new FuncProxy<string, ResultKind>(r => r == "Retry" ? ResultKind.Transient : ResultKind.Successful);
            FuncProxy<Exception, bool>                  exceptionHandler = new FuncProxy<Exception, bool>(ExceptionPolicy.Retry<IOException>().Invoke);
            FuncProxy<int, string, Exception, TimeSpan> delayHandler     = new FuncProxy<int, string, Exception, TimeSpan>((i, r, e) => Constants.Delay);

            ActionProxy<int, string, Exception> retryHandler     = new ActionProxy<int, string, Exception>();
            ActionProxy<string, Exception>      failedHandler    = new ActionProxy<string, Exception>();
            ActionProxy<string, Exception>      exhaustedHandler = new ActionProxy<string, Exception>();

            // Create Reliable<#= optionalAsync #>Func
            Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc = new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(
                func.Invoke,
                2, // Exception, Result, Exception, ...
                resultHandler   .Invoke,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliableFunc.Retrying         += retryHandler    .Invoke;
                reliableFunc.Failed           += failedHandler   .Invoke;
                reliableFunc.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            func            .Invoking += Expect.ArgumentsAfterDelay<<#= inputTypeArguments #>>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            func            .Invoking += Expect.AfterDelay(Constants.MinDelay);
<#
        }
#>
            resultHandler   .Invoking += Expect.Result("Retry");
            exceptionHandler.Invoking += Expect.Exception(typeof(IOException));
            delayHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            retryHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            failedHandler   .Invoking += Expect.Nothing<string, Exception>();
            exhaustedHandler.Invoking += Expect.OnlyException<string>(typeof(IOException));

            // Invoke
            using (CancellationTokenSource tokenSource = new CancellationTokenSource())
                assertInvoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token, typeof(IOException));

            // Validate the number of calls
            Assert.AreEqual(3, func             .Calls);
            Assert.AreEqual(1, resultHandler    .Calls);
            Assert.AreEqual(2, exceptionHandler .Calls);
            Assert.AreEqual(2, delayHandler     .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(2, retryHandler    .Calls);
                Assert.AreEqual(0, failedHandler   .Calls);
                Assert.AreEqual(1, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_Canceled_Func

        private void Invoke_Canceled_Func(Action<Reliable<#= optionalAsync #>Func<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken> invoke, bool addEventHandlers<#= async ? ", bool useSynchronousFunc" : string.Empty #>)
        {
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            // Create a user-defined action that will throw an exception depending on whether its canceled
            Func<string> flakyFunc = FlakyFunc.Create<string, IOException>("Retry");
<#
        if (async)
        {
#>
            // Note: We need to separately check the use of asynchronous and synchronous methods when checking cancellation
            FuncProxy<#= tokenInputFuncTypeArguments #> func = useSynchronousFunc
                ? new FuncProxy<#= tokenInputFuncTypeArguments #>(
                    (<#= arguments #><#= optionalComma #>token) =>
                    {
                        token.ThrowIfCancellationRequested();
                        return Task.FromResult(flakyFunc());
                    })
                : new FuncProxy<#= tokenInputFuncTypeArguments #>(
                    async (<#= arguments #><#= optionalComma #>token) =>
                    {
                        token.ThrowIfCancellationRequested();
                        return await Task.FromResult(flakyFunc());
                    });
<#
        }
        else
        {
#>
            FuncProxy<#= tokenInputFuncTypeArguments #> func = new FuncProxy<#= tokenInputFuncTypeArguments #>(
                (<#= arguments #><#= optionalComma #>token) =>
                {
                    token.ThrowIfCancellationRequested();
                    return flakyFunc();
                });
<#
        }
#>

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<string, ResultKind>               resultHandler    = new FuncProxy<string, ResultKind>(r => ResultKind.Transient);
            FuncProxy<Exception, bool>                  exceptionHandler = new FuncProxy<Exception, bool>(ExceptionPolicy.Transient.Invoke);
            FuncProxy<int, string, Exception, TimeSpan> delayHandler     = new FuncProxy<int, string, Exception, TimeSpan>((i, r, e) => Constants.Delay);

            ActionProxy<int, string, Exception> retryHandler     = new ActionProxy<int, string, Exception>();
            ActionProxy<string, Exception>      failedHandler    = new ActionProxy<string, Exception>();
            ActionProxy<string, Exception>      exhaustedHandler = new ActionProxy<string, Exception>();

            // Create Reliable<#= optionalAsync #>Func
            Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc = new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(
                func.Invoke,
                Retries.Infinite, // Exception, Result, Exception, ...
                resultHandler   .Invoke,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliableFunc.Retrying         += retryHandler    .Invoke;
                reliableFunc.Failed           += failedHandler   .Invoke;
                reliableFunc.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
            func            .Invoking += Expect.ArgumentsAfterDelay<<#= inputTypeArguments #><#= optionalComma #>CancellationToken>(Arguments.Validate, Constants.MinDelay);
            resultHandler   .Invoking += Expect.Result("Retry");
            exceptionHandler.Invoking += Expect.Exception(typeof(IOException));
            delayHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            retryHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            failedHandler   .Invoking += Expect.Nothing<string, Exception>();
            exhaustedHandler.Invoking += Expect.OnlyException<string>(typeof(IOException));

            // Cancel the retry on its 3rd attempt
            func            .Invoking += (<#= arguments #><#= optionalComma #>t, c) =>
            {
                if (c.Calls == 3)
                    tokenSource.Cancel();
            };

            // Invoke, retry, and cancel
            Assert.That.ThrowsException<OperationCanceledException>(() => invoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token), allowedDerivedTypes: true);

            // Validate the number of calls
            Assert.AreEqual(3, func             .Calls);
            Assert.AreEqual(1, resultHandler    .Calls);
            Assert.AreEqual(1, exceptionHandler .Calls);
            Assert.AreEqual(2, delayHandler     .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(2, retryHandler    .Calls);
                Assert.AreEqual(0, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion

        #region Invoke_Canceled_Delay

        private void Invoke_Canceled_Delay(Action<Reliable<#= optionalAsync #>Func<<#= typeArguments #>><#= optionalComma #><#= inputTypeArguments #>, CancellationToken> invoke, bool addEventHandlers)
        {
            using CancellationTokenSource tokenSource = new CancellationTokenSource();

            // Create a user-defined action that will throw an exception depending on whether its canceled
            Func<string> flakyFunc = FlakyFunc.Create<string, IOException>("Retry");
            FuncProxy<#= inputFuncTypeArguments #> func = new FuncProxy<#= inputFuncTypeArguments #>(<#= GetExpressionDelegate(parameterCount, "flakyFunc()", async) #>);

            // Declare the various proxies for the input delegates and event handlers
            FuncProxy<string, ResultKind>               resultHandler    = new FuncProxy<string, ResultKind>(r => ResultKind.Transient);
            FuncProxy<Exception, bool>                  exceptionHandler = new FuncProxy<Exception, bool>(ExceptionPolicy.Transient.Invoke);
            FuncProxy<int, string, Exception, TimeSpan> delayHandler     = new FuncProxy<int, string, Exception, TimeSpan>((i, r, e) => Constants.Delay);

            ActionProxy<int, string, Exception> retryHandler     = new ActionProxy<int, string, Exception>();
            ActionProxy<string, Exception>      failedHandler    = new ActionProxy<string, Exception>();
            ActionProxy<string, Exception>      exhaustedHandler = new ActionProxy<string, Exception>();

            // Create Reliable<#= optionalAsync #>Func
            Reliable<#= optionalAsync #>Func<<#= typeArguments #>> reliableFunc = new Reliable<#= optionalAsync #>Func<<#= typeArguments #>>(
                func.Invoke,
                Retries.Infinite, // Exception, Result, Exception, ...
                resultHandler   .Invoke,
                exceptionHandler.Invoke,
                delayHandler    .Invoke);

            if (addEventHandlers)
            {
                reliableFunc.Retrying         += retryHandler    .Invoke;
                reliableFunc.Failed           += failedHandler   .Invoke;
                reliableFunc.RetriesExhausted += exhaustedHandler.Invoke;
            }

            // Define expectations
<#
        if (parameterCount > 0)
        {
#>
            func            .Invoking += Expect.ArgumentsAfterDelay<<#= inputTypeArguments #>>(Arguments.Validate, Constants.MinDelay);
<#
        }
        else
        {
#>
            func            .Invoking += Expect.AfterDelay(Constants.MinDelay);
<#
        }
#>
            resultHandler   .Invoking += Expect.Result("Retry");
            exceptionHandler.Invoking += Expect.Exception(typeof(IOException));
            delayHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            retryHandler    .Invoking += Expect.AlternatingAsc("Retry", typeof(IOException));
            failedHandler   .Invoking += Expect.Nothing<string, Exception>();
            exhaustedHandler.Invoking += Expect.OnlyException<string>(typeof(IOException));

            // Cancel the retry on its 3rd attempt before the delay
            delayHandler     .Invoking += (i, r, e, c) =>
            {
                if (c.Calls == 3)
                    tokenSource.Cancel();
            };

            // Invoke, retry, and cancel
            Assert.That.ThrowsException<OperationCanceledException>(() => invoke(reliableFunc<#= optionalComma #><#= argumentValues #>, tokenSource.Token), allowedDerivedTypes: true);

            // Validate the number of calls
            Assert.AreEqual(3, func             .Calls);
            Assert.AreEqual(1, resultHandler    .Calls);
            Assert.AreEqual(2, exceptionHandler .Calls);
            Assert.AreEqual(3, delayHandler     .Calls);

            if (addEventHandlers)
            {
                Assert.AreEqual(2, retryHandler    .Calls);
                Assert.AreEqual(0, failedHandler   .Calls);
                Assert.AreEqual(0, exhaustedHandler.Calls);
            }
        }

        #endregion
    }
}
<#
        SaveOutput($"Reliable{optionalAsync}Func.T{parameterCount + 1}.Test.cs");
    }
#>
<#= GetTemplateFileName() #> ran successfully
