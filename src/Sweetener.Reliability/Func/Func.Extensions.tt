<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="..\TextTemplating\Include.t4" #>// Generated from Func.Extensions.tt
using System;
using System.Threading.Tasks;

namespace Sweetener.Reliability
{
    /// <summary>
    /// A collection of methods to reliablty invoke functions.
    /// </summary>
    public static class FuncExtensions
    {
<#
    for (int parameterCount = 0; parameterCount <= MaxParameters; parameterCount++)
    {
        string arguments      = GetArguments     (parameterCount);
        string parameters     = GetParameters    (parameterCount);
        string typeParameters = GetTypeParameters(parameterCount) + (parameterCount > 0 ? ", TResult" : "TResult");
#>
        #region WithRetry<<#= typeParameters #>>

        /// <summary>
        /// Creates a reliable wrapper around the given <paramref name="func" />
        /// that will retry the operation based on the provided policies.
        /// </summary>
<#
        PrintFuncParamsXmlDoc(indent: 2, typeParameterCount: parameterCount, includeResultPolicy: false);
#>
        public static Func<<#= typeParameters #>> WithRetry<<#= typeParameters #>>(
            this Func<<#= typeParameters #>> func,
            int maxRetries,
            ExceptionPolicy exceptionPolicy,
            DelayPolicy delayPolicy)
            => WithRetry(func, maxRetries, r => ResultKind.Successful, exceptionPolicy, (i, r, e) => delayPolicy(i));

        /// <summary>
        /// Creates a reliable wrapper around the given <paramref name="func" />
        /// that will retry the operation based on the provided policies.
        /// </summary>
<#
        PrintFuncParamsXmlDoc(indent: 2, typeParameterCount: parameterCount, includeResultPolicy: false);
#>
        public static Func<<#= typeParameters #>> WithRetry<<#= typeParameters #>>(
            this Func<<#= typeParameters #>> func,
            int maxRetries,
            ExceptionPolicy exceptionPolicy,
            ComplexDelayPolicy<TResult> delayPolicy)
            => WithRetry(func, maxRetries, r => ResultKind.Successful, exceptionPolicy, delayPolicy);

        /// <summary>
        /// Creates a reliable wrapper around the given <paramref name="func" />
        /// that will retry the operation based on the provided policies.
        /// </summary>
<#
        PrintFuncParamsXmlDoc(indent: 2, typeParameterCount: parameterCount, includeResultPolicy: true);
#>
        public static Func<<#= typeParameters #>> WithRetry<<#= typeParameters #>>(
            this Func<<#= typeParameters #>> func,
            int maxRetries,
            ResultPolicy<TResult> resultPolicy,
            ExceptionPolicy exceptionPolicy,
            DelayPolicy delayPolicy)
            => WithRetry(func, maxRetries, resultPolicy, exceptionPolicy, (i, r, e) => delayPolicy(i));

        /// <summary>
        /// Creates a reliable wrapper around the given <paramref name="func" />
        /// that will retry the operation based on the provided policies.
        /// </summary>
<#
        PrintFuncParamsXmlDoc(indent: 2, typeParameterCount: parameterCount, includeResultPolicy: true);
#>
        public static Func<<#= typeParameters #>> WithRetry<<#= typeParameters #>>(
            this Func<<#= typeParameters #>> func,
            int maxRetries,
            ResultPolicy<TResult> resultPolicy,
            ExceptionPolicy exceptionPolicy,
            ComplexDelayPolicy<TResult> delayPolicy)
        {
            if (func == null)
                throw new ArgumentNullException(nameof(func));

            if (maxRetries < -1)
                throw new ArgumentOutOfRangeException(nameof(maxRetries));

            if (resultPolicy == null)
                throw new ArgumentNullException(nameof(resultPolicy));

            if (exceptionPolicy == null)
                throw new ArgumentNullException(nameof(exceptionPolicy));

            if (delayPolicy == null)
                throw new ArgumentNullException(nameof(delayPolicy));

            return (<#= parameters #>) =>
            {
                TResult result;
                int attempt = 0;
            Attempt:
                attempt++;
                try
                {
                    result = func(<#= arguments #>);
                }
                catch (Exception e)
                {
                    if (!exceptionPolicy(e) || attempt > maxRetries)
                        throw e;

                    Task.Delay(delayPolicy(attempt, default, e)).Wait();
                    goto Attempt;
                }

                ResultKind kind = resultPolicy(result);
                if (kind != ResultKind.Retryable || attempt > maxRetries)
                    return result;

                Task.Delay(delayPolicy(attempt, result, null)).Wait();
                goto Attempt;
            };
        }

        #endregion

<#
}
#>
    }
}
