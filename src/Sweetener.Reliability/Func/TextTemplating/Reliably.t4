<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="$(MSBuildProjectDirectory)\TextTemplating\Include.t4" #>// Generated from <#= GetTemplateFileName() #>
using System;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;

namespace Sweetener.Reliability
{
    static partial class Reliably
    {
<#
    string resultType        = async ? "Task<TResult>" : "TResult";
    string cancellationCheck = async ? "isCanceled"    : "e.IsCancellation(cancellationToken)";

    if (!async)
    {
#>
        #region Invoke
<#
        foreach (bool stateful in new bool[2] { false, true })
        {
            string typeParam          = stateful ? "<TState, TResult>" : "<TResult>";
            string optionalStateParam = stateful ? "TState state, "    : string.Empty;
            string optionalStateArg   = stateful ? "state, "           : string.Empty;
#>

<#
            PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: false, hasResultHandler: false);
#>
        public static TResult Invoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>int maxRetries, ExceptionHandler exceptionHandler, DelayHandler delayHandler)
            => Invoke(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler.ToComplex<TResult>());

<#
            PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: false, hasResultHandler: false);
#>
        public static TResult Invoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>int maxRetries, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler)
            => Invoke(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler);

<#
            PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: false, hasResultHandler: true);
#>
        public static TResult Invoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, DelayHandler delayHandler)
            => Invoke(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, resultHandler, exceptionHandler, delayHandler.ToComplex<TResult>());

<#
            PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: false, hasResultHandler: true);
#>
        public static TResult Invoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler)
            => Invoke(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, resultHandler, exceptionHandler, delayHandler);

<#
            PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: true, hasResultHandler: false);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static TResult Invoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ExceptionHandler exceptionHandler, DelayHandler delayHandler)
            => Invoke(func, <#= optionalStateArg #>cancellationToken, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler.ToComplex<TResult>());

<#
            PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: true, hasResultHandler: false);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static TResult Invoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler)
            => Invoke(func, <#= optionalStateArg #>cancellationToken, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler);

<#
            PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: true, hasResultHandler: true);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static TResult Invoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, DelayHandler delayHandler)
            => Invoke(func, <#= optionalStateArg #>cancellationToken, maxRetries, resultHandler, exceptionHandler, delayHandler.ToComplex<TResult>());

<#
            PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: true, hasResultHandler: true);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static TResult Invoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler)
        {
            if (func == null)
                throw new ArgumentNullException(nameof(func));

            if (maxRetries < Retries.Infinite)
                throw new ArgumentOutOfRangeException(nameof(maxRetries));

            if (resultHandler == null)
                throw new ArgumentNullException(nameof(resultHandler));

            if (exceptionHandler == null)
                throw new ArgumentNullException(nameof(exceptionHandler));

            if (delayHandler == null)
                throw new ArgumentNullException(nameof(delayHandler));

            TResult result;
            int attempt = 0;

        Attempt:
            attempt++;

            try
            {
                result = func(<#= stateful ? "state" : string.Empty #>);
            }
            catch (Exception e)
            {
                if (e.IsCancellation(cancellationToken) || !exceptionHandler(e) || (maxRetries != Retries.Infinite && attempt > maxRetries))
                    throw;

                Task.Delay(delayHandler(attempt, default, e), cancellationToken).Wait();
                goto Attempt;
            }

            ResultKind kind = resultHandler(result);
            if (kind != ResultKind.Transient || (maxRetries != Retries.Infinite && attempt > maxRetries))
                return result;

            Task.Delay(delayHandler(attempt, result, default), cancellationToken).Wait();
            goto Attempt;
        }
<#
        }
#>

        #endregion

<#
    }
#>
        #region InvokeAsync

<#
    foreach (bool stateful in new bool[2] { false, true })
    {
        string typeParam          = stateful ? "<TState, TResult>"       : "<TResult>";
        string funcTypeParam      = stateful ? $"<TState, {resultType}>" : $"<{resultType}>";
        string optionalStateParam = stateful ? "TState state, "          : string.Empty;
        string optionalStateArg   = stateful ? "state, "                 : string.Empty;

        PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: false, hasResultHandler: false);
#>
        public static Task<TResult> InvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>int maxRetries, ExceptionHandler exceptionHandler, DelayHandler delayHandler)
            => InvokeAsync(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler.ToComplex<TResult>());

<#
        PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: false, hasResultHandler: false);
#>
        public static Task<TResult> InvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>int maxRetries, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler)
            => InvokeAsync(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler);

<#
        PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: false, hasResultHandler: true);
#>
        public static Task<TResult> InvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, DelayHandler delayHandler)
            => InvokeAsync(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, resultHandler, exceptionHandler, delayHandler.ToComplex<TResult>());

<#
        PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: false, hasResultHandler: true);
#>
        public static Task<TResult> InvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler)
            => InvokeAsync(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, resultHandler, exceptionHandler, delayHandler);

<#
        PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: true, hasResultHandler: false);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static Task<TResult> InvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ExceptionHandler exceptionHandler, DelayHandler delayHandler)
            => InvokeAsync(func, <#= optionalStateArg #>cancellationToken, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler.ToComplex<TResult>());

<#
        PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: true, hasResultHandler: false);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static Task<TResult> InvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler)
            => InvokeAsync(func, <#= optionalStateArg #>cancellationToken, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler);

<#
        PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: true, hasResultHandler: true);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static Task<TResult> InvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, DelayHandler delayHandler)
            => InvokeAsync(func, <#= optionalStateArg #>cancellationToken, maxRetries, resultHandler, exceptionHandler, delayHandler.ToComplex<TResult>());

<#
        PrintReliablyInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: true, hasResultHandler: true);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static async Task<TResult> InvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler)
        {
            if (func == null)
                throw new ArgumentNullException(nameof(func));

            if (maxRetries < Retries.Infinite)
                throw new ArgumentOutOfRangeException(nameof(maxRetries));

            if (resultHandler == null)
                throw new ArgumentNullException(nameof(resultHandler));

            if (exceptionHandler == null)
                throw new ArgumentNullException(nameof(exceptionHandler));

            if (delayHandler == null)
                throw new ArgumentNullException(nameof(delayHandler));

            <#= async ? "Task<TResult>? t" : "TResult result" #>;
            int attempt = 0;

        Attempt:
<#
        if (async)
        {
#>
            t = null;
<#
        }
#>
            attempt++;

            try
            {
<#
        if (async)
        {
#>
                t = func(<#= stateful ? "state" : string.Empty #>);
                if (t == null)
                    goto Invalid;

                await t.ConfigureAwait(false);
<#
        }
        else
        {
#>
                result = func(<#= stateful ? "state" : string.Empty #>);
<#
        }
#>
            }
            catch (Exception e)
            {
<#
        if (async)
        {
#>
                bool isCanceled = t != null ? t.IsCanceled : e.IsCancellation(cancellationToken);
<#
        }
#>
                if (<#= cancellationCheck #> || !exceptionHandler(e) || (maxRetries != Retries.Infinite && attempt > maxRetries))
                    throw;

                await Task.Delay(delayHandler(attempt, default, e), cancellationToken).ConfigureAwait(false);
                goto Attempt;
            }

<#
        if (async)
        {
#>
            TResult result = t.Result;
<#
        }
#>
            ResultKind kind = resultHandler(result);
            if (kind != ResultKind.Transient || (maxRetries != Retries.Infinite && attempt > maxRetries))
                return result;

            await Task.Delay(delayHandler(attempt, result, default), cancellationToken).ConfigureAwait(false);
            goto Attempt;
<#
        if (async)
        {
#>

        Invalid:
            throw new InvalidOperationException(SR.InvalidTaskResult);
<#
        }
#>
        }

<#
    }
#>
        #endregion

<#
    if (!async)
    {
#>
        #region TryInvoke
<#
        foreach (bool stateful in new bool[2] { false, true })
        {
            string typeParam          = stateful ? "<TState, TResult>" : "<TResult>";
            string optionalStateParam = stateful ? "TState state, "    : string.Empty;
            string optionalStateArg   = stateful ? "state, "           : string.Empty;
#>

<#
            PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: false, hasResultHandler: false);
#>
        public static bool TryInvoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>int maxRetries, ExceptionHandler exceptionHandler, DelayHandler delayHandler, out TResult result)
            => TryInvoke(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler.ToComplex<TResult>(), out result);

<#
            PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: false, hasResultHandler: false);
#>
        public static bool TryInvoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>int maxRetries, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler, out TResult result)
            => TryInvoke(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler, out result);

<#
            PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: false, hasResultHandler: true);
#>
        public static bool TryInvoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, DelayHandler delayHandler, out TResult result)
            => TryInvoke(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, resultHandler, exceptionHandler, delayHandler.ToComplex<TResult>(), out result);

<#
            PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: false, hasResultHandler: true);
#>
        public static bool TryInvoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler, out TResult result)
            => TryInvoke(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, resultHandler, exceptionHandler, delayHandler, out result);

<#
            PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: true, hasResultHandler: false);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static bool TryInvoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ExceptionHandler exceptionHandler, DelayHandler delayHandler, out TResult result)
            => TryInvoke(func, <#= optionalStateArg #>cancellationToken, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler.ToComplex<TResult>(), out result);

<#
            PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: true, hasResultHandler: false);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static bool TryInvoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler, out TResult result)
            => TryInvoke(func, <#= optionalStateArg #>cancellationToken, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler, out result);

<#
            PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: true, hasResultHandler: true);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static bool TryInvoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, DelayHandler delayHandler, out TResult result)
            => TryInvoke(func, <#= optionalStateArg #>cancellationToken, maxRetries, resultHandler, exceptionHandler, delayHandler.ToComplex<TResult>(), out result);

<#
            PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: false, hasToken: true, hasResultHandler: true);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static bool TryInvoke<#= typeParam #>(Func<#= typeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler, out TResult result)
        {
            if (func == null)
                throw new ArgumentNullException(nameof(func));

            if (maxRetries < Retries.Infinite)
                throw new ArgumentOutOfRangeException(nameof(maxRetries));

            if (resultHandler == null)
                throw new ArgumentNullException(nameof(resultHandler));

            if (exceptionHandler == null)
                throw new ArgumentNullException(nameof(exceptionHandler));

            if (delayHandler == null)
                throw new ArgumentNullException(nameof(delayHandler));

            int attempt = 0;

        Attempt:
            attempt++;

            try
            {
                result = func(<#= stateful ? "state" : string.Empty #>);
            }
            catch (Exception e)
            {
                if (e.IsCancellation(cancellationToken))
                    throw;

                if (!exceptionHandler(e) || (maxRetries != Retries.Infinite && attempt > maxRetries))
                    goto Fail;

                Task.Delay(delayHandler(attempt, default, e), cancellationToken).Wait();
                goto Attempt;
            }

            switch (resultHandler(result))
            {
                case ResultKind.Successful:
                    return true;
                case ResultKind.Fatal:
                    goto Fail;
                default:
                    if (maxRetries != Retries.Infinite && attempt > maxRetries)
                        goto Fail;

                    Task.Delay(delayHandler(attempt, result, default), cancellationToken).Wait();
                    goto Attempt;
            }

        Fail:
            result = default!;
            return false;
        }
<#
        }
#>

        #endregion

<#
    }
#>
        #region TryInvokeAsync

<#
    foreach (bool stateful in new bool[2] { false, true })
    {
        string typeParam          = stateful ? "<TState, TResult>"       : "<TResult>";
        string funcTypeParam      = stateful ? $"<TState, {resultType}>" : $"<{resultType}>";
        string optionalStateParam = stateful ? "TState state, "          : string.Empty;
        string optionalStateArg   = stateful ? "state, "                 : string.Empty;

        PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: false, hasResultHandler: false);
#>
        public static Task<Optional<TResult>> TryInvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>int maxRetries, ExceptionHandler exceptionHandler, DelayHandler delayHandler)
            => TryInvokeAsync(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler.ToComplex<TResult>());

<#
        PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: false, hasResultHandler: false);
#>
        public static Task<Optional<TResult>> TryInvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>int maxRetries, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler)
            => TryInvokeAsync(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler);

<#
        PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: false, hasResultHandler: true);
#>
        public static Task<Optional<TResult>> TryInvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, DelayHandler delayHandler)
            => TryInvokeAsync(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, resultHandler, exceptionHandler, delayHandler.ToComplex<TResult>());

<#
        PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: false, hasResultHandler: true);
#>
        public static Task<Optional<TResult>> TryInvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler)
            => TryInvokeAsync(func, <#= optionalStateArg #>CancellationToken.None, maxRetries, resultHandler, exceptionHandler, delayHandler);

<#
        PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: true, hasResultHandler: false);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static Task<Optional<TResult>> TryInvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ExceptionHandler exceptionHandler, DelayHandler delayHandler)
            => TryInvokeAsync(func, <#= optionalStateArg #>cancellationToken, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler.ToComplex<TResult>());

<#
        PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: true, hasResultHandler: false);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static Task<Optional<TResult>> TryInvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler)
            => TryInvokeAsync(func, <#= optionalStateArg #>cancellationToken, maxRetries, ResultPolicy.Default<TResult>(), exceptionHandler, delayHandler);

<#
        PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: true, hasResultHandler: true);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static Task<Optional<TResult>> TryInvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, DelayHandler delayHandler)
            => TryInvokeAsync(func, <#= optionalStateArg #>cancellationToken, maxRetries, resultHandler, exceptionHandler, delayHandler.ToComplex<TResult>());

<#
        PrintReliablyTryInvokeFuncXmlDoc(indent: 2, stateful, isAsync: true, hasToken: true, hasResultHandler: true);
#>
        [SuppressMessage("Design", "CA1068:CancellationToken parameters must come last", Justification = "Token is not used for canceling operation, and API mirrors TaskFactory.StartNew")]
        public static async Task<Optional<TResult>> TryInvokeAsync<#= typeParam #>(Func<#= funcTypeParam #> func, <#= optionalStateParam #>CancellationToken cancellationToken, int maxRetries, ResultHandler<TResult> resultHandler, ExceptionHandler exceptionHandler, ComplexDelayHandler<TResult> delayHandler)
        {
            if (func == null)
                throw new ArgumentNullException(nameof(func));

            if (maxRetries < Retries.Infinite)
                throw new ArgumentOutOfRangeException(nameof(maxRetries));

            if (resultHandler == null)
                throw new ArgumentNullException(nameof(resultHandler));

            if (exceptionHandler == null)
                throw new ArgumentNullException(nameof(exceptionHandler));

            if (delayHandler == null)
                throw new ArgumentNullException(nameof(delayHandler));

<#
        if (async)
        {
#>
            Task<TResult>? t;
<#
        }
#>
            int attempt = 0;

        Attempt:
<#
        if (async)
        {
#>
            t = null;
<#
        }
        else
        {
#>
            TResult result;
<#
        }
#>
            attempt++;

            try
            {
<#
        if (async)
        {
#>
                t = func(<#= stateful ? "state" : string.Empty #>);
                if (t == null)
                    goto Invalid;

                await t.ConfigureAwait(false);
<#
        }
        else
        {
#>
                result = func(<#= stateful ? "state" : string.Empty #>);
<#
        }
#>
            }
            catch (Exception e)
            {
<#
        if (async)
        {
#>
                bool isCanceled = t != null ? t.IsCanceled : e.IsCancellation(cancellationToken);
<#
        }
#>
                if (<#= cancellationCheck #>)
                    throw;

                if (!exceptionHandler(e) || (maxRetries != Retries.Infinite && attempt > maxRetries))
                    goto Fail;

                await Task.Delay(delayHandler(attempt, default, e), cancellationToken).ConfigureAwait(false);
                goto Attempt;
            }

<#
        if (async)
        {
#>
            TResult result = t.Result;
<#
        }
#>
            switch (resultHandler(result))
            {
                case ResultKind.Successful:
                    return result;
                case ResultKind.Fatal:
                    goto Fail;
                default:
                    if (maxRetries != Retries.Infinite && attempt > maxRetries)
                        goto Fail;

                    Task.Delay(delayHandler(attempt, result, default), cancellationToken).Wait();
                    goto Attempt;
            }

        Fail:
            return Optional<TResult>.Undefined;
<#
        if (async)
        {
#>

        Invalid:
            throw new InvalidOperationException(SR.InvalidTaskResult);
<#
        }
#>
        }

<#
    }
#>
        #endregion
    }
}
