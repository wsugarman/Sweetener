<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="$(SrcDirectory)TextTemplating\Include.t4" #><#+

    const int MaxExceptionParameters = 8;

    public void PrintParamsXmlDoc(int parameterCount, int indent)
    {
        if (parameterCount < 0)
            throw new ArgumentOutOfRangeException(nameof(parameterCount));

        string spaces = new string(' ', indent * SpacesPerTab);
        for (int i = 1; i <= parameterCount; i++)
        {
            string param     = parameterCount == 1 ? "arg" : "arg" + i;
            string qualifier = parameterCount == 1 ? string.Empty : GetNthWord(i) + " ";
#>
<#= spaces #>/// <param name="<#= param #>">The <#= qualifier #>parameter of the method that this reliable delegate encapsulates.</param>
<#+
        }
    }

    public void PrintTypeParamsXmlDoc(int typeParameterCount, int indent, bool includeResult)
    {
        if (typeParameterCount < 0)
            throw new ArgumentOutOfRangeException(nameof(typeParameterCount));

        string spaces = new string(' ', indent * SpacesPerTab);
        for (int i = 1; i <= typeParameterCount; i++)
        {
            string typeParameter = typeParameterCount == 1 ? "T" : "T" + i;
            string qualifier     = typeParameterCount == 1 ? string.Empty : GetNthWord(i) + " ";
#>
<#= spaces #>/// <typeparam name="<#= typeParameter #>">The type of the <#= qualifier #>parameter of the method that this reliable delegate encapsulates.</typeparam>
<#+
        }

        if (includeResult)
        {
#>
<#= spaces #>/// <typeparam name="TResult">The type of the return value of the method that this reliable delegate encapsulates.</typeparam>
<#+
        }
    }

    public void PrintReliableFuncCtorXmlDoc(int indent, int typeParameterCount = -1, bool includeResultHandler = false, bool includeReturnsXmlDoc = false)
        => PrintReliableCtorXmlDoc(indent, typeParameterCount, isFunc: true, includeResultHandler, includeReturnsXmlDoc);

    public void PrintReliableActionCtorXmlDoc(int indent, int typeParameterCount = -1, bool includeReturnsXmlDoc = false)
        => PrintReliableCtorXmlDoc(indent, typeParameterCount, isFunc: false, includeResultHandler: false, includeReturnsXmlDoc: includeReturnsXmlDoc);

    private void PrintReliableCtorXmlDoc(int indent, int typeParameterCount, bool isFunc, bool includeResultHandler, bool includeReturnsXmlDoc)
    {
        if (typeParameterCount < -1)
            throw new ArgumentOutOfRangeException(nameof(typeParameterCount));

        // Add the type parameters after the summary
        if (typeParameterCount > -1)
        {
            PrintTypeParamsXmlDoc(typeParameterCount, indent, includeResult: isFunc);
        }

        string spaces = new string(' ', indent * SpacesPerTab);
#>
<#= spaces #>/// <param name="<#= isFunc ? "func" : "action" #>">The <#= isFunc ? "function" : "action" #> to encapsulate.</param>
<#= spaces #>/// <param name="maxRetries">The maximum number of retry attempts.</param>
<#+
        if (includeResultHandler)
        {
#>
<#= spaces #>/// <param name="resultHandler">A function that determines which results are valid.</param>
<#+
        }
#>
<#= spaces #>/// <param name="exceptionHandler">A function that determines which errors are transient.</param>
<#= spaces #>/// <param name="delayHandler">A function that determines how long wait to wait between retries.</param>
<#+
        if (includeReturnsXmlDoc)
        {
#>
<#= spaces #>/// <returns>A reliable delegate that encapsulates the <paramref name="<#= isFunc ? "func" : "action" #>" />.</returns>
<#+
        }
#>
<#= spaces #>/// <exception cref="ArgumentNullException">
<#= spaces #>/// <paramref name="<#= isFunc ? "func" : "action" #>" />, <#= includeResultHandler ? "<paramref name=\"resultHandler\" /> " : "" #><paramref name="exceptionHandler" />, or <paramref name="delayHandler" /> is <see langword="null" />.
<#= spaces #>/// </exception>
<#= spaces #>/// <exception cref="ArgumentOutOfRangeException">
<#= spaces #>/// <paramref name="maxRetries" /> is a negative number other than <c>-1</c>, which represents an infinite number of retries.
<#= spaces #>/// </exception>
<#+
    }

    public void PrintReliablyInvokeActionXmlDoc(int indent, bool isStateful, bool isAsync, bool hasToken)
        => PrintReliablyXmlDoc(indent, isTry: false, isFunc: false, isStateful, isAsync, hasToken, false);

    public void PrintReliablyInvokeFuncXmlDoc(int indent, bool isStateful, bool isAsync, bool hasToken, bool hasResultHandler)
        => PrintReliablyXmlDoc(indent, isTry: false, isFunc: true, isStateful, isAsync, hasToken, hasResultHandler);

    public void PrintReliablyTryInvokeActionXmlDoc(int indent, bool isStateful, bool isAsync, bool hasToken)
        => PrintReliablyXmlDoc(indent, isTry: true, isFunc: false, isStateful, isAsync, hasToken, false);

    public void PrintReliablyTryInvokeFuncXmlDoc(int indent, bool isStateful, bool isAsync, bool hasToken, bool hasResultHandler)
        => PrintReliablyXmlDoc(indent, isTry: true, isFunc: true, isStateful, isAsync, hasToken, hasResultHandler);

    private void PrintReliablyXmlDoc(int indent, bool isTry, bool isFunc, bool isStateful, bool isAsync, bool hasToken, bool hasResultHandler)
    {
        string spaces = new string(' ', indent * SpacesPerTab);
        string delegateName = isFunc ? "func" : "action";

        if (isTry)
        {
#>
<#= spaces #>/// <summary>
<#= spaces #>/// <#= isAsync ? "Asynchronously a" : "A" #>ttempts to successfully invoke the <paramref name="<#= delegateName #>" /> despite transient problems.
<#= spaces #>/// </summary>
<#+
        }
        else
        {
#>
<#= spaces #>/// <summary>
<#= spaces #>/// <#= isAsync ? "Asynchronously i" : "I" #>nvokes the given <paramref name="<#= delegateName #>" /> despite transient problems
<#= spaces #>/// using the provided execution policies.
<#= spaces #>/// </summary>
<#+
        }

        if (isStateful)
        {
#>
<#= spaces #>/// <typeparam name="TState">The type of the state object passed to the <paramref name="<#= delegateName #>"/>.</typeparam>
<#+
        }

        if (isFunc)
        {
#>
<#= spaces #>/// <typeparam name="TResult">The type of the result produced by the <paramref name="<#= delegateName #>"/>.</typeparam>
<#+
        }

#>
<#= spaces #>/// <param name="<#= delegateName #>">The <#= delegateName #> to reliably invoke.</param>
<#+

        if (isStateful)
        {
#>
<#= spaces #>/// <param name="state">An object containing data to be used by the <paramref name="<#= delegateName #>" /> delegate.</param>
<#+
        }

        if (hasToken)
        {
#>
<#= spaces #>/// <param name="cancellationToken">The <see cref="CancellationToken" /> used to determine whether the <paramref name="<#= delegateName #>" /> was canceled.</param>
<#+
        }

#>
<#= spaces #>/// <param name="maxRetries">The maximum number of retry attempts.</param>
<#+

        if (isFunc && hasResultHandler)
        {
#>
<#= spaces #>/// <param name="resultHandler">A function that determines which results are valid.</param>
<#+
        }

#>
<#= spaces #>/// <param name="exceptionHandler">A function that determines which exceptions are transient.</param>
<#= spaces #>/// <param name="delayHandler">A function that determines how long wait to wait between attempts.</param>
<#+

        if (isTry && isFunc && !isAsync)
        {
#>
<#= spaces #>/// <param name="result">
<#= spaces #>/// When this method returns, contains the result of the <paramref name="<#= delegateName #>" />,
<#= spaces #>/// if it completed successfully, or the default value if it failed. The parameter
<#= spaces #>/// is passed unitialized; any value originally supplied in <paramref name="result" /> will be overwritten.
<#= spaces #>/// </param>
<#+
        }

        if (isTry && !isAsync)
        {
#>
<#= spaces #>/// <returns>
<#= spaces #>/// <see langword="true" /> if <paramref name="<#= delegateName #>" /> was invoked sucessfully;
<#= spaces #>/// otherwise, <see langword="false" />.
<#= spaces #>/// </returns>
<#+
        }
        else if (isFunc)
        {
            if (isAsync)
            {
#>
<#= spaces #>/// <returns>
<#= spaces #>/// A task that represents the asynchronous invoke operation. The value of the <c>TResult</c>
<#= spaces #>/// parameter <#= isTry ? "optionally " : string.Empty #>contains the return value of the <paramref name="<#= delegateName #>" /><#= isTry ? "." : string.Empty #>
<#+
                if (isTry)
                {
#>
<#= spaces #>/// if the delegate was invoked successfully.
<#+
                }
#>
<#= spaces #>/// </returns>
<#+
            }
            else
            {
#>
<#= spaces #>/// <returns>The return value of the <paramref name="<#= delegateName #>" />.</returns>
<#+
            }
        }
        else if (isAsync)
        {
            if (isTry)
            {
#>
<#= spaces #>/// <returns>
<#= spaces #>/// A task that represents the asynchronous invoke operation. The value of the <c>TResult</c>
<#= spaces #>/// parameter contains <see langword="true" /> if <paramref name="<#= delegateName #>" />
<#= spaces #>/// was invoked sucessfully; otherwise, <see langword="false" />.
<#= spaces #>/// </returns>
<#+
            }
            else
            {
#>
<#= spaces #>/// <returns>A task that represents the asynchronous invoke operation.</returns>
<#+
            }
        }

#>
<#= spaces #>/// <exception cref="ArgumentNullException">
<#= spaces #>/// <paramref name="<#= delegateName #>" />, <#= isFunc && hasResultHandler ? "<paramref name=\"resultHandler\" /> " : "" #><paramref name="exceptionHandler" />, or <paramref name="delayHandler" /> is <see langword="null" />.
<#= spaces #>/// </exception>
<#= spaces #>/// <exception cref="ArgumentOutOfRangeException">
<#= spaces #>/// <paramref name="maxRetries" /> is a negative number other than <c>-1</c>, which represents an infinite number of retries.
<#= spaces #>/// </exception>
<#+
        if (hasToken)
        {
#>
<#= spaces #>/// <exception cref="ObjectDisposedException">
<#= spaces #>/// The underlying <see cref="CancellationTokenSource" /> has already been disposed.
<#= spaces #>/// </exception>
<#+
        }

        if (hasToken && !isAsync)
        {
#>
<#= spaces #>/// <exception cref="OperationCanceledException">The <paramref name="cancellationToken"/> was canceled.</exception>
<#+
        }
    }
#>
