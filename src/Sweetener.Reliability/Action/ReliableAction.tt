<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ include file="..\TextTemplating\Include.t4" #>// Generated from ReliableAction.tt
using System;
using System.Threading;

namespace Sweetener.Reliability
{
<#

for (int parameterCount = 0; parameterCount <= MaxParameters; parameterCount++)
{
    string arguments      = GetArguments     (parameterCount);
    string parameters     = GetParameters    (parameterCount);
    string typeParameters = GetTypeParameters(parameterCount);

    string typeParametersCode    = typeParameters == string.Empty ? string.Empty : "<" + typeParameters + ">";
    string typeParametersComment = typeParameters == string.Empty ? string.Empty : "{" + typeParameters + "}";
#>
    #region ReliableAction<#= typeParametersCode #>

    /// <summary>
    /// A wrapper to reliably invoke a delegate in case of transient issues.
    /// </summary>
<#
    for (int i = 1; i <= parameterCount; i++)
    {
        string typeParameter   = parameterCount == 1 ? "T" : "T" + i;
        string parameterPrefix = parameterCount == 1 ? string.Empty : GetNthWord(i) + " ";
#>
    /// <typeparam name="<#= typeParameter #>">The type of the <#= parameterPrefix #>parameter of the underlying delegate.</typeparam>
<#
    }
#>
    public sealed class ReliableAction<#= typeParametersCode #>
    {
        /// <summary>
        /// Occurs when the action must be retried due to a transient exception.
        /// </summary>
        public event Action<int> Retrying;

        /// <summary>
        /// Gets the maximum number of retry attempts.
        /// </summary>
        /// <value>
        /// The maximum number of attempts the underlying <see cref="Action<#= typeParametersComment #>"/>
        /// should be invoked if there are transient exceptions.
        /// </value>
        public int MaxRetries { get; }

        private readonly Action<#= typeParametersCode #> _action;
        private readonly DelayPolicy _delayPolicy;
        private readonly RetryPolicy _retryPolicy;

        /// <summary>
        /// Initializes a new instance of the <see cref="ReliableAction<#= typeParametersComment #>"/>
        /// class that executes the given <see cref="Action<#= typeParametersComment #>"/> at most a
        /// specific number of times based on the provided policies.
        /// </summary>
        /// <param name="action">The underlying action to invoke.</param>
        /// <param name="maxRetries">The maximum number of retry attempts.</param>
        /// <param name="delayPolicy">The policy that determines how long wait to wait between retries.</param>
        /// <param name="retryPolicy">The policy that determines which errors are transient.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="maxRetries"/> is a negative number other than -1, which represents an infinite number of retries.
        /// </exception>
        public ReliableAction(Action<#= typeParametersCode #> action, int maxRetries, DelayPolicy delayPolicy, RetryPolicy retryPolicy)
        {
            if (maxRetries < -1)
                throw new ArgumentOutOfRangeException(nameof(maxRetries));

            _action      = action;
            _delayPolicy = delayPolicy;
            _retryPolicy = retryPolicy;
            MaxRetries   = maxRetries;
        }

        /// <summary>
        /// Attempts to successfully invoke the underlying delegate despite transient exceptions.
        /// </summary>
<#
    for (int i = 1; i <= parameterCount; i++)
    {
        string argument       = parameterCount == 1 ? "arg" : "arg" + i;
        string argumentPrefix = parameterCount == 1 ? string.Empty : GetNthWord(i) + " ";
#>
        /// <param name="<#= argument #>">The <#= argumentPrefix #>argument for the underlying delegate.</param>
<#
    }
#>
        /// <returns>
        /// <see langword="true"/> if the delegate completed without throwing an exception
        /// within the maximum number of retries; otherwise, <see langword="false"/>.
        /// </returns>
        public bool TryInvoke(<#= parameters #>)
        {
            TimeSpan delay;
            int attempt = 0;
            do
            {
                attempt++;
                try
                {
                    _action(<#= arguments #>);
                    return true;
                }
                catch (Exception e)
                {
                    if (!_retryPolicy.IsTransient(e))
                        return false;

                    delay = _delayPolicy.GetExceptionDelay(attempt, e);
                }
            } while (ContinueRetry(attempt, delay));

            return false;
        }

        /// <summary>
        /// Invokes the underlying delegate and attempts to retry if it encounters transient exceptions.
        /// </summary>
<#
    for (int i = 1; i <= parameterCount; i++)
    {
        string argument       = parameterCount == 1 ? "arg" : "arg" + i;
        string argumentPrefix = parameterCount == 1 ? string.Empty : GetNthWord(i) + " ";
#>
        /// <param name="<#= argument #>">The <#= argumentPrefix #>argument for the underlying delegate.</param>
<#
    }
#>
        /// <exception cref="RetriesExhaustedException">The number of attempts exceeded <see cref="MaxRetries"/>.</exception>
        public void Invoke(<#= parameters #>)
        {
            TimeSpan delay;
            int attempt = 0;
            do
            {
                attempt++;
                try
                {
                    _action(<#= arguments #>);
                    return;
                }
                catch (Exception e)
                {
                    if (!_retryPolicy.IsTransient(e))
                        throw e;

                    delay = _delayPolicy.GetExceptionDelay(attempt, e);
                }
            } while (ContinueRetry(attempt, delay));

            throw new RetriesExhaustedException(attempt);
        }

        private bool ContinueRetry(int attempt, TimeSpan delay)
        {
            bool continueRetry = attempt <= MaxRetries;
            if (continueRetry)
            {
                Thread.Sleep(delay);
                Retrying?.Invoke(attempt);
            }

            return continueRetry;
        }
    }

    #endregion

<#
    }
#>
}
